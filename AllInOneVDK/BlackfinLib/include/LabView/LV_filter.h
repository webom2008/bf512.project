/************************************************************************
 *
 * LV_filter.h
 *
 * (c) Copyright 2005-2006 Analog Devices, Inc.  All rights reserved.
 * $Revision: 4 $
 ************************************************************************/

#ifndef __LV_FILTER_DEFINED
#define __LV_FILTER_DEFINED

#include <stdlib.h>
#include <string.h>
#include <filter.h>

#ifdef __cplusplus
  extern "C" {
#endif


/* Passing of complex 2D-matrices from LabView into Blackfin LibDSP

   | Function argument generated by LabView |
        |
         --> | Pointer to data structure |
                  |
                   --> | Number of rows                |
                       | Number of columns             |
                       | Start complex matrix elements |  <= Address required
                       | ..                            |     by BLackfin libdsp
                                                             library functions.

   cfft2d_fr16_LV ( const complex_fract16 ** const *_input, ... )
   {
        cfft2d_fr16( (complex_fract16*) ( (*_input) + 2), ... );
   }


   Passing of complex 1D-vectors from LabView into Blackfin LibDSP

   | Function argument generated by LabView |
        |
         --> | Pointer to data structure |
                  |
                   --> | Number of elements            |
                       | Start complex matrix elements |  <= Address required
                       | ..                            |     by BLackfin libdsp
                                                             library functions.

   cfft_fr16_LV ( const complex_fract16 ** const _input[], ... )
   {
        cfft_fr16( (complex_fract16*) ( (*_input) + 1), ... );
   }
*/



/* FFTS */

#pragma always_inline
static __inline void
cfft_fr16_LV ( const complex_fract16 ** const _input[],
               complex_fract16 ** _temp[],
               complex_fract16 ** _output[],
               const complex_fract16 ** const _twiddle_table[],
               int _twiddle_stride, int _fft_size )
{
   cfft_fr16( (complex_fract16*) ((*_input) + 1), 
              (complex_fract16*) ((*_temp) + 1), 
              (complex_fract16*) ((*_output) + 1), 
              (complex_fract16*) ((*_twiddle_table) + 1), 
              _twiddle_stride, _fft_size, 0, 0 );
}
 
#pragma always_inline
static __inline void
ifft_fr16_LV ( const complex_fract16 ** const _input[],
               complex_fract16 ** _temp[],
               complex_fract16 ** _output[],
               const complex_fract16 ** const _twiddle_table[],
               int _twiddle_stride, int _fft_size )
{
   ifft_fr16( (complex_fract16*) ((*_input) + 1),
              (complex_fract16*) ((*_temp) + 1),
              (complex_fract16*) ((*_output) + 1),
              (complex_fract16*) ((*_twiddle_table) + 1),
              _twiddle_stride, _fft_size, 0, 0 );
}

#pragma always_inline
static __inline void
rfft_fr16_LV ( const fract16 _input[],
               complex_fract16 ** _temp[],
               complex_fract16 ** _output[],
               const complex_fract16 ** const _twiddle_table[],
               int _twiddle_stride, int _fft_size )
{
   rfft_fr16( _input,
              (complex_fract16*) ((*_temp) + 1),
              (complex_fract16*) ((*_output) + 1),
              (complex_fract16*) ((*_twiddle_table) + 1),
              _twiddle_stride, _fft_size, 0, 0 );
}

#pragma always_inline
static __inline void
cfft2d_fr16_LV ( const complex_fract16 ** const *_input,
                 complex_fract16 ** _temp, 
                 complex_fract16 ** _output,
                 const complex_fract16 ** const _twiddle_table[],
                 int _twiddle_stride, int _fft_size )
{
   cfft2d_fr16( (complex_fract16*) ((*_input) + 2),
                (complex_fract16*) ((*_temp) + 2),
                (complex_fract16*) ((*_output) + 2),
                (complex_fract16*) ((*_twiddle_table) + 1),
                _twiddle_stride, _fft_size, 0, 0 );
}

#pragma always_inline
static __inline void
ifft2d_fr16_LV ( const complex_fract16 * const *_input,
                 complex_fract16 ** _temp,
                 complex_fract16 ** _output,
                 const complex_fract16 ** const _twiddle_table[],
                 int _twiddle_stride, int _fft_size )
{
   ifft2d_fr16( (complex_fract16*) ((*_input) + 2),
                (complex_fract16*) ((*_temp) + 2),
                (complex_fract16*) ((*_output) + 2),
                (complex_fract16*) ((*_twiddle_table) + 1),
                _twiddle_stride, _fft_size, 0, 0 );
}

#pragma always_inline
static __inline void
rfft2d_fr16_LV ( const fract16 * _input,
                 complex_fract16 ** _temp,
                 complex_fract16 ** _output,
                 const complex_fract16 ** const _twiddle_table[],
                 int _twiddle_stride, int _fft_size )
{
   rfft2d_fr16( _input,
                (complex_fract16*) ((*_temp) + 2),
                (complex_fract16*) ((*_output) + 2),
                (complex_fract16*) ((*_twiddle_table) + 1),
                _twiddle_stride, _fft_size, 0, 0 );
}


/* TWIDDLE TABLE GENERATORS */

#pragma always_inline
static __inline void
twidfft_fr16_LV ( complex_fract16 ** _twiddle_table[], 
                  int _fft_size )
{
   twidfftrad2_fr16 ( (complex_fract16*) ((*_twiddle_table) + 1), 
                      _fft_size );
}

#pragma always_inline
static __inline void
twidfft2d_fr16_LV ( complex_fract16 ** _twiddle_table[], 
                    int _fft_size )
{
   twidfft2d_fr16 ( (complex_fract16*) ((*_twiddle_table) + 1), 
                    _fft_size );
}


/* CFIR_FR16() */

static void
cfir_fr16_LV( const complex_fract16 ** const _input[],
              complex_fract16  ** _output[], 
              int  _length_input,
              const complex_fract16 ** const _coefficients[],
              int  _length_coefficients,
              int  _continue)
{
   /* Internal data outwith user control */
   static cfir_state_fr16   *_state_ptr = NULL;
   static complex_fract16   *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
       /* Execute  
          a)  at program start to create data structures
          b)  while user has not set continue to one
       */

       /* Create an instance of the state structure if it 
          does not already exist 
       */
       if ( _state_ptr == NULL ) 
       {
            _state_ptr = ( cfir_state_fr16*  )  
                               malloc( sizeof ( cfir_state_fr16  ) );
       }

       /* If delay_ptr is NULL, create a new data array, 
          otherwise, resize the data array if the size has changed 
                     or do nothing if the size has remained the same
       */
       _delay_ptr = ( complex_fract16* )  
                          realloc( _delay_ptr, 
                              sizeof(complex_fract16)*_length_coefficients);

       /* Need to zero the data array before its first use */
       memset (_delay_ptr, 0, sizeof(complex_fract16)*_length_coefficients);

       /* Set-up filter state structure */
       cfir_init ( *_state_ptr, (complex_fract16*) ((*_coefficients) + 1), 
                   _delay_ptr, _length_coefficients );
   }

   /* Invoke Blackfin libdsp filter function */
   cfir_fr16 ( (complex_fract16*) ((*_input) + 1), 
               (complex_fract16*) ((*_output) + 1), 
               _length_input, _state_ptr );
}


/* FIR_FR16() */

static void 
fir_fr16_LV( const fract16  _input[], 
             fract16  _output[], 
             int  _length_input,
             const fract16  _coefficients[],
             int  _length_coefficients,
             int  _continue )
{
   /* Internal data outwith user control */
   static fir_state_fr16   *_state_ptr = NULL;
   static fract16          *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
       /* Execute  
          a)  at program start to create data structures
          b)  while user has not set continue to one
       */

       /* Create an instance of the state structure 
          if it does not already exist 
       */
       if ( _state_ptr == NULL ) 
       {
           _state_ptr = ( fir_state_fr16* ) 
                                 malloc( sizeof ( fir_state_fr16  ) );
       }

       /* If delay_ptr is NULL, create a new data array, 
          otherwise, resize the data array if the size has changed 
                     or do nothing if the size has remained the same
       */
       _delay_ptr = ( fract16* ) 
                         realloc( _delay_ptr, 
                            sizeof ( fract16 ) * _length_coefficients );

       /* Need to zero the data array before its first use */
       memset ( _delay_ptr, 0, 
                            sizeof ( fract16 ) * _length_coefficients );

       /* Set-up filter state structure */
       fir_init ( *_state_ptr, (fract16*)_coefficients, 
                  _delay_ptr, _length_coefficients, 0 );
   }

   /* Invoke Blackfin libdsp filter function */
   fir_fr16 ( _input, _output, _length_input, _state_ptr );
}


/* FIR_DECIMA_FR16() */

static void
fir_decima_fr16_LV( const fract16  _input[],
                    fract16  _output[],
                    int  _length_input,
                    const fract16  _coefficients[],
                    int  _length_coefficients,
                    int  _decimation_index,
                    int  _continue )
{
   /* Internal data outwith user control */
   static fir_state_fr16   *_state_ptr = NULL;
   static fract16          *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
     /* Execute
        a)  at program start to create data structures
        b)  while user has not set continue to one
     */

     /* Create an instance of the state structure
        if it does not already exist
     */
     if ( _state_ptr == NULL )
     {
         _state_ptr = ( fir_state_fr16* )
                               malloc( sizeof ( fir_state_fr16  ) );
     }

     /* If delay_ptr is NULL, create a new data array,
        otherwise, resize the data array if the size has changed
                   or do nothing if the size has remained the same
     */
     _delay_ptr = ( fract16* )
                       realloc( _delay_ptr,
                          sizeof ( fract16 ) * _length_coefficients );

     /* Need to zero the data array before its first use */
     memset ( _delay_ptr, 0,
                          sizeof ( fract16 ) * _length_coefficients );

       /* Set-up filter state structure */
       fir_init ( *_state_ptr, (fract16*)_coefficients, 
                  _delay_ptr, _length_coefficients, _decimation_index );
   }

   /* Invoke Blackfin libdsp filter function */
   fir_decima_fr16( _input, _output, _length_input, _state_ptr );
}


/* FIR_INTERP_FR16() */

static void
fir_interp_fr16_LV( const fract16  _input[],
                    fract16  _output[],
                    int  _length_input,
                    const fract16  _coefficients[],
                    int  _length_coeffs_polyphase, 
                    int  _interpolation_index, 
                    int  _continue )
{
   /* Internal data outwith user control */
   static fir_state_fr16   *_state_ptr = NULL;
   static fract16          *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
       /* Execute
          a)  at program start to create data structures
          b)  while user has not set continue to one
       */

       /* Create an instance of the state structure
          if it does not already exist
       */
       if ( _state_ptr == NULL )
       {
           _state_ptr = ( fir_state_fr16* )
                                 malloc( sizeof ( fir_state_fr16  ) );
       }

       /* If delay_ptr is NULL, create a new data array,
          otherwise, resize the data array if the size has changed
                     or do nothing if the size has remained the same
       */
       _delay_ptr = ( fract16* )
                         realloc( _delay_ptr,
                            sizeof ( fract16 ) * _length_coeffs_polyphase );

       /* Need to zero the data array before its first use */
       memset ( _delay_ptr, 0,
                            sizeof ( fract16 ) * _length_coeffs_polyphase );

       /* Set-up filter state structure */
       fir_init ( *_state_ptr, (fract16*)_coefficients, _delay_ptr, 
                  _length_coeffs_polyphase, _interpolation_index );
   }

   /* Invoke Blackfin libdsp filter function */
   fir_interp_fr16( _input, _output, _length_input, _state_ptr );
}


/* IIR_FR16() */

static void 
iir_fr16_LV( const fract16  _input[],
             fract16  _output[], 
             int  _length_input,
             const fract16  _coefficients[],
             int  _biquad_stages,
             int  _continue )
{
   /* Internal data outwith user control */
   static iir_state_fr16   *_state_ptr = NULL;
   static fract16          *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
        /* Execute  
           a)  at program start to create data structures
           b)  while user has not set continue to one
        */

        /* Create an instance of the state structure 
           if it does not already exist 
        */
        if ( _state_ptr == NULL )
        {
            _state_ptr = ( iir_state_fr16* )  
                             malloc( sizeof ( iir_state_fr16  ) );
        }

        /* If delay_ptr is NULL, create a new data array, 
           otherwise, resize the data array if the size has changed 
                      or do nothing if the size has remained the same
        */
        _delay_ptr = ( fract16* )
                          realloc( _delay_ptr, 
                                   sizeof(fract16) * _biquad_stages * 2);

        /* Need to zero the data array before its first use */
        memset ( _delay_ptr, 0, sizeof(fract16) *  _biquad_stages * 2 );

        /* Set-up filter state structure */
        iir_init ( *_state_ptr, (fract16*)_coefficients, 
                   _delay_ptr, _biquad_stages );
   }

   /* Invoke Blackfin libdsp filter function */
   iir_fr16 ( _input, _output, _length_input, _state_ptr );
}


/* IIR_DF1_FR16() */

static void
iir_df1_fr16_LV( const fract16  _input[],
                 fract16  _output[], 
                 int  _length_input,
                 const fract16  _coefficients[],
                 int  _biquad_stages,
                 int  _continue )
{
   /* Internal data outwith user control */
   static iirdf1_state_fr16   *_state_ptr = NULL;
   static fract16             *_delay_ptr = NULL;

   if ( _continue == 0 )
   {
       /* Execute  
          a)  at program start to create data structures
          b)  while user has not set continue to one
       */

       /* Create an instance of the state structure 
          if it does not already exist 
       */
       if ( _state_ptr == NULL ) 
       {
           _state_ptr = ( iirdf1_state_fr16*  )  
                             malloc( sizeof ( iirdf1_state_fr16  ) );
       }

       /* If delay_ptr is NULL, create a new data array, 
          otherwise, resize the data array if the size has changed 
                     or do nothing if the size has remained the same
       */
       _delay_ptr = ( fract16* ) 
                        realloc( _delay_ptr, 
                            sizeof(fract16)*((_biquad_stages*4)+2));

       /* Need to zero the data array before its first use */
       memset ( _delay_ptr, 0, 
                            sizeof(fract16)*((_biquad_stages*4)+2));

       /* Set-up filter state structure */
       iirdf1_init ( *_state_ptr, (fract16*)_coefficients, 
                     _delay_ptr, _biquad_stages );
   }

   /* Invoke Blackfin libdsp filter function */
   iirdf1_fr16 ( _input, _output, _length_input, _state_ptr );
}


#ifdef __cplusplus
  }
#endif
#endif  /* __LV_FILTER_DEFINED */
