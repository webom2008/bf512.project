/*  bfrom.h - definitions for on-chip Boot ROM and L1ROM
 ** Copyright Analog Devices 2008-2010. All Rights Reserved.
 */
#ifndef _BFROM_H
#define _BFROM_H

#if defined(__ECC__)
#pragma system_header /* bfrom.h */
#endif

#ifdef _MISRA_RULES
#pragma diag(push)
#pragma diag(suppress:misra_rule_5_2)
#pragma diag(suppress:misra_rule_5_3:"ADI header will re-use identifiers")
#pragma diag(suppress:misra_rule_5_4:"ADI header will re-use identifiers")
#pragma diag(suppress:misra_rule_5_6)
#pragma diag(suppress:misra_rule_5_7)
#pragma diag(suppress:misra_rule_6_3)
#pragma diag(suppress:misra_rule_6_4)
#pragma diag(suppress:misra_rule_8_1)
#pragma diag(suppress:misra_rule_8_5)
#pragma diag(suppress:misra_rule_11_3)
#pragma diag(suppress:misra_rule_16_5)
#pragma diag(suppress:misra_rule_18_1)
#pragma diag(suppress:misra_rule_18_4)
#pragma diag(suppress:misra_rule_19_4)
#pragma diag(suppress:misra_rule_19_7:"Macro functions OTP_OFFSET and OTP_BITPOS are required in C and assembly so they cannot be implemented as functions")
#endif /* _MISRA_RULES */

#if    !defined(__ADSPBF54x__) \
    && !defined(__ADSPBF52x__) \
    && !defined(__ADSPBF51x__) \
    && !defined(__ADSPBF50x__) \
    && !defined(__ADSPBF59x__)
#error Unsupported processor detected in Blackfin Boot ROM Header bfrom.h: A valid ADSP-BF52x, ADSP-BF54x, ADSP-BF51x, ADSP-BF50x or ADSP-BF59x processor macro is not defined
#endif

/* ******************************************************************************************* */
/*                                                                                             */
/*   Data Types used in API                                                                    */
/*                                                                                             */
/* ******************************************************************************************* */

#include <services_types.h>


/* ******************************************************************************************* */
/*                                                                                             */
/*   Flags for syscontrol() routine                                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#define SYSCTRL_READ        0x00000000    /* read registers */
#define SYSCTRL_WRITE       0x00000001    /* write registers */ 
#define SYSCTRL_SYSRESET    0x00000002    /* perform system reset */
#define SYSCTRL_SOFTRESET   0x00000004    /* perform core and system reset */
#define SYSCTRL_VRCTL       0x00000010    /* read/write VR_CTL register */
	#define SYSCTRL_EXTVOLTAGE  0x00000020    /* VDDINT supplied externally */
	#define SYSCTRL_INTVOLTAGE  0x00000000    /* VDDINT generated by on-chip regulator */
	#define SYSCTRL_OTPVOLTAGE  0x00000040    /* For Factory Purposes Only */
	#define SYSCTRL_HIBERNATE  0x00000080    /* Go into Hibernate mode */
    	                                     /* NOTE: use only in conjunction with SYSCTRL_VRCTL flag
        	                                    and a valid VR_CTL register parameter value.
            	                                Failure to do so will prevent entering hibernation mode */
#define SYSCTRL_PLLCTL      0x00000100    /* read/write PLL_CTL register */
#define SYSCTRL_PLLDIV      0x00000200    /* read/write PLL_DIV register */
#define SYSCTRL_LOCKCNT     0x00000400    /* read/write PLL_LOCKCNT register */
#define SYSCTRL_PLLSTAT     0x00000800    /* read/write PLL_STAT register */
#define SYSCTRL_COLDBOOT    0x40000000    /* when called at cold boot */
#define SYSCTRL_PREBOOT     0x80000000    /* when called from preboot */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Flags for OtpCommand() routine                                                            */
/*                                                                                             */
/* ******************************************************************************************* */



#define OTP_INIT            0x00000001
#define OTP_CLOSE           0x00000002


/* ******************************************************************************************* */
/*                                                                                             */
/*   Flags for OtpRead and OtpWrite() routines                                                 */
/*                                                                                             */
/* ******************************************************************************************* */



#define OTP_LOWER_HALF           0x00000000    /* select upper/lower 64-bit half (bit 0) */
#define OTP_UPPER_HALF           0x00000001
#define OTP_NO_ECC               0x00000010    /* do not use ECC */
#define OTP_LOCK                 0x00000020    /* sets page protection bit for page */
#define OTP_CHECK_FOR_PREV_WRITE 0x00000080    /* for ECC corrected writes, check if page has been previously written */




/* ******************************************************************************************* */
/*                                                                                             */
/*   Return Codes for OtpCommand, OtpRead and OtpWrite() routines                              */
/*                                                                                             */
/* ******************************************************************************************* */


/* Error codes */
#define OTP_SUCCESS          0x0000
/* Error Bits */
#define OTP_MASTER_ERROR     0
#define OTP_WRITE_ERROR      1
#define OTP_READ_ERROR       2
#define OTP_ACC_VIO_ERROR    3
#define OTP_DATA_MULT_ERROR  4
#define OTP_ECC_MULT_ERROR   5
#define OTP_PREV_WR_ERROR    6
#define OTP_SB_DEFECT_ERROR  7

/* Warning Bits */
#define OTP_DATA_SB_WARN     8
#define OTP_ECC_SB_WARN      9


/* ******************************************************************************************* */
/*                                                                                             */
/*   Boot block header's bit fields                                                            */
/*                                                                                             */
/* ******************************************************************************************* */

#define HDRSGN              0xFF000000
#define HDRCHK              0x00FF0000
#define DMACODE             0x0000000F 


/* ******************************************************************************************* */
/*                                                                                             */
/*   Boot Flags (part of block header's block code field)                                      */
/*                                                                                             */
/* ******************************************************************************************* */


#define BFLAG_FINAL         0x00008000   /* final block in stream */
#define BFLAG_FIRST         0x00004000   /* first block in stream */
#define BFLAG_INDIRECT      0x00002000   /* load data via intermediate buffer */
#define BFLAG_IGNORE        0x00001000   /* ignore block payload */
#define BFLAG_INIT          0x00000800   /* call initcode routine */
#define BFLAG_CALLBACK      0x00000400   /* call callback routine */
#define BFLAG_QUICKBOOT     0x00000200   /* boot block only when BFLAG_WAKEUP=0 */
#define BFLAG_FILL          0x00000100   /* fill memory with 32-bit argument value */
#define BFLAG_AUX           0x00000020   /* load auxiliary header -- reserved */
#define BFLAG_SAVE          0x00000010   /* save block on power down -- reserved */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Boot Flags (global flags for pFlag word)                                                  */
/*                                                                                             */
/* ******************************************************************************************* */


#define BFLAG_NORESTORE     0x80000000   /* do not restore MMR register when done */
#define BFLAG_RESET         0x40000000   /* issue system reset when done */
#define BFLAG_RETURN        0x20000000   /* issue RTS instead of jumping to EVT1 vector */
#define BFLAG_NEXTDXE       0x10000000   /* parse stream via Next DXE pointer */
#define BFLAG_WAKEUP        0x08000000   /* WURESET bit was a '1', enable quickboot */
#define BFLAG_SLAVE         0x04000000   /* boot mode is a slave mode */
#define BFLAG_PERIPHERAL    0x02000000   /* boot mode is a peripheral mode */
#define BFLAG_NOAUTO        0x01000000   /* skip automatic device detection */
#define BFLAG_ALTERNATE     0x00800000   /* use alternate boot source */
#define BFLAG_FASTREAD      0x00400000   /* use 0xB command in SPI master mode */
#define BFLAG_TYPE          0x00100000   /* device type (number of address bytes) */ 
   #define BFLAG_TYPE1      0x00000000   /* device type (1 SPI/TWI address bytes, Small Page NAND Flash) */
   #define BFLAG_TYPE2      0x00100000   /* device type (2 SPI/TWI address bytes, Large Page NAND Flash) */
   #define BFLAG_TYPE3      0x00200000   /* device type (3 SPI/TWI address bytes, NAND reserved) */
   #define BFLAG_TYPE4      0x00300000   /* device type (4 SPI/TWI address bytes, NAND reserved) */
#define BFLAG_HDRINDIRECT   0x00080000   /* boot block headers via intermediate buffer */
#define BFLAG_HOOK          0x00040000   /* call hook routine after initialization */
#define BFLAG_TEST          0x00020000   /* factory testing */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Callback Flags                                                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#define CBFLAG_FINAL        0x00000008
#define CBFLAG_FIRST        0x00000004
#define CBFLAG_DIRECT       0x00000001


/* ******************************************************************************************* */
/*                                                                                             */
/*   Boot ROM Jump Table Entries                                                               */
/*                                                                                             */
/* ******************************************************************************************* */


#define BFROM_FINALINIT      0xEF000002
#define BFROM_PDMA           0xEF000004
#define BFROM_MDMA           0xEF000006
#define BFROM_MEMBOOT        0xEF000008
#define BFROM_SPIBOOT        0xEF00000A
#define BFROM_TWIBOOT        0xEF00000C
#define BFROM_OTPBOOT        0xEF00000E
#define BFROM_NANDBOOT       0xEF000010

#define BFROM_SECURE_ENTRY   0xEF000014
#define BFROM_OTP_ECC        0xEF000016
#define BFROM_OTP_COMMAND    0xEF000018
#define BFROM_OTP_READ       0xEF00001A
#define BFROM_OTP_WRITE      0xEF00001C
#define BFROM_ECC_LUTADDR    0xEF00001E

#define BFROM_BOOTKERNEL     0xEF000020
#define BFROM_GETPORT        0xEF000022
#define BFROM_NMI            0xEF000024
#define BFROM_HWERROR        0xEF000026
#define BFROM_EXCEPTION      0xEF000028
#define BFROM_EMUENTRY       0xEF00002A

#define BFROM_CRC32          0xEF000030
#define BFROM_CRC32POLY      0xEF000032
#define BFROM_CRC32CALLBACK  0xEF000034
#define BFROM_CRC32INITCODE  0xEF000036
#define BFROM_SYSCONTROL     0xEF000038

#if defined(__ADSPBF50x__)

	#define BFROM_FLASHPROTECT         0xEF00003A
	#define BFROM_FLASHPROTECTINITCODE 0xEF00003C

#endif

/* ******************************************************************************************* */
/*                                                                                             */
/*   Flags and Argument for BFROM_FLASHPROTECT routine                                         */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined(__ADSPBF50x__)

	#define FLASH_LOCK_CONTROL			0x80000000	/* Controls locking of the upper byte of the FLASH_CONTROL register */
	#define FLASH_PROTECT_ENABLE 		0x20000000	/* Controls the Vpp Flash Protect signal */
	#define FLASH_PROTECT_DISABLE 		0x10000000	/* Controls the Vpp Flash Protect signal */
	#define FLASH_RESET_DISABLE 		0x02000000	/* Controls the Flash Reset signal */
	#define FLASH_RESET_ENABLE			0x01000000	/* Controls the Flash Reset signal */
	#define FLASH_LOCKDOWN_ENABLE 		0x00010000	/* Enables the block lockdown feature */
	#define FLASH_LOCKDOWN_START_BLOCK 	0x000000FF	/* Block number to start the lockdown */
	#define FLASH_LOCKDOWN_NUM_BLOCKS 	0x0000FF00	/* Number of block to lockdown */
	#define FLASH_BLOCK_SHIFT_VAL 		0x00000010	/* shift value for FLASH_LOCKDOWN_START_BLOCK to generate the byte address */
	#define FLASH_MAIN_BLOCK_SIZE 		0x00010000	/* Size in bytes of a main block */
	
#endif	


/* ******************************************************************************************* */
/*                                                                                             */
/*   Boot ROM Data Constants with Bit Fields                                                   */
/*                                                                                             */
/* ******************************************************************************************* */


#define BK_REVISION          0xEF000040
#define BK_ZEROS             0xEF000048
#define BK_ONES              0xEF00004C
#define BK_DATECODE          0xEF000050

#if defined (_LANGUAGE_C)
# define pBK_REVISION         ((const unsigned long *)BK_REVISION)
# define pBK_ZEROS            ((const unsigned long *)BK_ZEROS)
# define pBK_ONES             ((const unsigned long *)BK_ONES)
# define pBK_DATECODE         ((const unsigned long *)BK_DATECODE)
#endif /* _LANGUAGE_C */

#define BK_ID                0xFF000000
#define BK_PROJECT           0x00FF0000
#define BK_VERSION           0x0000FF00
#define BK_UPDATE            0x000000FF

#define BK_YEAR              0xFFFF0000
#define BK_MONTH             0x0000FF00
#define BK_DAY               0x000000FF




/* ******************************************************************************************* */
/*                                                                                             */
/*   Predefined OTP Pages to be used with bfrom_OtpRead()                                      */
/*                                                                                             */
/* ******************************************************************************************* */


#define FPS00                0x0004
#define FPS01                0x0005
#define FPS02                0x0006
#define FPS03                0x0007
#define FPS04                0x0008
#define FPS05                0x0009
#define FPS06                0x000A
#define FPS07                0x000B
#define FPS08                0x000C
#define FPS09                0x000D
#define FPS10                0x000E
#define FPS11                0x000F

#define CPS00                0x0010
#define CPS01                0x0011
#define CPS02                0x0012
#define CPS03                0x0013
#define CPS04                0x0014
#define CPS05                0x0015
#define CPS06                0x0016
#define CPS07                0x0017

#define PBS00                0x0018
#define PBS01                0x0019
#define PBS02                0x001A
#define PBS03                0x001B



/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS00L                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


#define OTP_VR_CTL_P             0 
#define OTP_VR_CTL_M             0x0000FFFF  /* lower 32-bit word */
#define OTP_PLL_CTL_P            16 
#define OTP_PLL_CTL_M            0xFFFF0000  /* lower 32-bit word */
#define OTP_PLL_DIV_P            32
#define OTP_PLL_DIV_M            0x000000FF  /* upper 32-bit word */
#define OTP_SPI_BAUD_P           40
#define OTP_SPI_BAUD_M           0x00000700  /* upper 32-bit word */
#define OTP_SPI_FASTREAD_P       43          
#define OTP_SPI_FASTREAD_M       0x00000800  /* upper 32-bit word */
#define OTP_TWI_CLKDIV_P         44         
#define OTP_TWI_CLKDIV_M         0x00001000  /* upper 32-bit word */
#define OTP_TWI_PRESCALE_P       45 
#define OTP_TWI_PRESCALE_M       0x0000E000  /* upper 32-bit word */
#define OTP_TWI_TYPE_P           48 
#define OTP_TWI_TYPE_M           0x00030000  /* upper 32-bit word */
#define OTP_SET_PLL_P            50
#define OTP_SET_PLL_M            0x00040000  /* upper 32-bit word */
#define OTP_SET_VR_P             51
#define OTP_SET_VR_M             0x00080000  /* upper 32-bit word */
#define OTP_RESETOUT_HWAIT_P     52  
#define OTP_RESETOUT_HWAIT_M     0x00100000  /* upper 32-bit word */


#if defined(__ADSPBF54x__)

    #define OTP_ALTERNATE_HWAIT_P    53
    #define OTP_ALTERNATE_HWAIT_M    0x00200000  /* upper 32-bit word */

    /* bit 54 reserved */

#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    /* bits 53 to 54 reserved */

#endif


#define OTP_LOAD_PBS00H_P        55
#define OTP_LOAD_PBS00H_M        0x00800000  /* upper 32-bit word */
#define OTP_LOAD_PBS01L_P        56
#define OTP_LOAD_PBS01L_M        0x01000000  /* upper 32-bit word */
#define OTP_LOAD_PBS01H_P        57
#define OTP_LOAD_PBS01H_M        0x02000000  /* upper 32-bit word */
#define OTP_LOAD_PBS02L_P        58
#define OTP_LOAD_PBS02L_M        0x04000000  /* upper 32-bit word */
#define OTP_LOAD_PBS02H_P        59
#define OTP_LOAD_PBS02H_M        0x08000000  /* upper 32-bit word */
#define OTP_LOAD_PBS03L_P        60
#define OTP_LOAD_PBS03L_M        0x10000000  /* upper 32-bit word */
#define OTP_LOAD_PBS03H_P        61
#define OTP_LOAD_PBS03H_M        0x20000000  /* upper 32-bit word */
#define OTP_INVALID_P            62
#define OTP_INVALID_M            0xC0000000  /* upper 32-bit word */



/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS00H                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


#define OTP_EBIU_AMBCTL_P        0
#define OTP_EBIU_AMBCTL_M        0x0000FFFF  /* lower 32-bit word */

#if defined(__ADSPBF54x__)

    #define OTP_EBIU_FCTL_P          16
    #define OTP_EBIU_FCTL_M          0xFFFF0000  /* lower 32-bit word */

    #define OTP_EBIU_MODE_P          32
    #define OTP_EBIU_MODE_M          0x000000FF  /* upper 32-bit word */

#elif defined(__ADSPBF52x__)  || defined(__ADSPBF51x__)

    /* bits 16 to 39 reserved */

#endif
        
    
#define OTP_EBIU_AMG_P           40
#define OTP_EBIU_AMG_M           0x00000F00  /* upper 32-bit word */


#if defined(__ADSPBF54x__)

    #define OTP_EBIU_DEVSEQ_P        44
    #define OTP_EBIU_DEVSEQ_M        0x0000F000  /* upper 32-bit word */
    #define OTP_EBIU_DEVCFG_P        48
    #define OTP_EBIU_DEVCFG_M        0xFFFF0000  /* upper 32-bit word */ 

#elif defined(__ADSPBF52x__)  || defined(__ADSPBF51x__)

    /* bits 16 to 63 reserved */

#endif



/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS01L                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


/* bits 0 to 63 reserved */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS01H                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


#define OTP_BMODE00_DIS_P           0
#define OTP_BMODE00_DIS_M           0x00000001  /* lower 32-bit word */
#define OTP_BMODE01_DIS_P           1
#define OTP_BMODE01_DIS_M           0x00000002  /* lower 32-bit word */
#define OTP_BMODE02_DIS_P           2
#define OTP_BMODE02_DIS_M           0x00000004  /* lower 32-bit word */
#define OTP_BMODE03_DIS_P           3
#define OTP_BMODE03_DIS_M           0x00000008  /* lower 32-bit word */
#define OTP_BMODE04_DIS_P           4
#define OTP_BMODE04_DIS_M           0x00000010  /* lower 32-bit word */
#define OTP_BMODE05_DIS_P           5
#define OTP_BMODE05_DIS_M           0x00000020  /* lower 32-bit word */
#define OTP_BMODE06_DIS_P           6
#define OTP_BMODE06_DIS_M           0x00000040  /* lower 32-bit word */
#define OTP_BMODE07_DIS_P           7
#define OTP_BMODE07_DIS_M           0x00000080  /* lower 32-bit word */
#define OTP_BMODE08_DIS_P           8
#define OTP_BMODE08_DIS_M           0x00000100  /* lower 32-bit word */
#define OTP_BMODE09_DIS_P           9
#define OTP_BMODE09_DIS_M           0x00000200  /* lower 32-bit word */
#define OTP_BMODE10_DIS_P           10
#define OTP_BMODE10_DIS_M           0x00000400  /* lower 32-bit word */
#define OTP_BMODE11_DIS_P           11
#define OTP_BMODE11_DIS_M           0x00000800  /* lower 32-bit word */
#define OTP_BMODE12_DIS_P           12
#define OTP_BMODE12_DIS_M           0x00001000  /* lower 32-bit word */
#define OTP_BMODE13_DIS_P           13
#define OTP_BMODE13_DIS_M           0x00002000  /* lower 32-bit word */
#define OTP_BMODE14_DIS_P           14
#define OTP_BMODE14_DIS_M           0x00004000  /* lower 32-bit word */
#define OTP_BMODE15_DIS_P           15
#define OTP_BMODE15_DIS_M           0x00008000  /* lower 32-bit word */
#define OTP_NFC_CTL_P               16
#define OTP_NFC_CTL_M               0x00FF0000  /* lower 32-bit word */ 
#define OTP_START_PAGE_P            24
#define OTP_START_PAGE_M            0xFF000000  /* lower 32-bit word */

/* bits 32 to 63 reserved */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS02L                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined(__ADSPBF54x__)

    #define OTP_EBIU_DDRCTL0_P          0
    #define OTP_EBIU_DDRCTL0_M          0xFFFFFFFF  /* lower 32-bit word */
    #define OTP_EBIU_DDRCTL1_P          32
    #define OTP_EBIU_DDRCTL1_M          0xFFFFFFFF  /* upper 32-bit word */

#elif defined(__ADSPBF52x__)  || defined(__ADSPBF51x__)

    #define OTP_EBIU_SDGCTL_P           0
    #define OTP_EBIU_SDGCTL_M           0xFFFFFFFF  /* lower 32-bit word */    
    #define OTP_EBIU_SDBCTL_P           32
    #define OTP_EBIU_SDBCTL_M           0x0000FFFF  /* upper 32-bit word */    
    #define OTP_EBIU_SDRCC_P            48
    #define OTP_EBIU_SDRCC_M            0x0FFF0000  /* upper 32-bit word */
    
    /* bits 60 to 62 reserved */
    
    #define OTP_EBIU_POWERON_DUMMY_WRITE_P      63
    #define OTP_EBIU_POWERON_DUMMY_WRITE_M      0x80000000  /* upper 32-bit word */
    
#endif




/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS02H                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined(__ADSPBF54x__)

    #define OTP_EBIU_DDRCTL2L_P         0
    #define OTP_EBIU_DDRCTL2L_M         0x0000FFFF  /* lower 32-bit word */    
    #define OTP_EBIU_DDRCTL3L_P         16
    #define OTP_EBIU_DDRCTL3L_M         0xFFFF0000  /* lower 32-bit word */
    
    #define OTP_EBIU_DDRQUEL_P          32
    #define OTP_EBIU_DDRQUEL_M          0x0000FFFF  /* upper 32-bit word */
    
    /* bits 48 to 63 reserved */    
    
#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

   /* bits 0 to 63 reserved */
    
#endif



/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS03L                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


/* bits 0 to 63 reserved */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Bit Fields in OTP Half Page PBS03H                                                        */
/*                                                                                             */
/* ******************************************************************************************* */


/* bits 0 to 63 reserved */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Macros to be used along with _P versions of above bit fields                              */
/*                                                                                             */
/* ******************************************************************************************* */


#define OTP_OFFSET(x) (((x)>>5)<<2)
#define OTP_BITPOS(x) ((x)&0x1F)



/* ******************************************************************************************* */
/*                                                                                             */
/*   Block Cipher Modes of Operation                                                           */
/*                                                                                             */
/* ******************************************************************************************* */


#define BLOCK_CIPHER_MODE_ECB  0
#define BLOCK_CIPHER_MODE_CBC  1
#define BLOCK_CIPHER_MODE_OFB  2
#define BLOCK_CIPHER_MODE_CTR  3




/* ******************************************************************************************* */
/*                                                                                             */
/*   Flags for AesInit() routines                                                              */
/*                                                                                             */
/* ******************************************************************************************* */


#define AES_ENCRYPTION         (0x01)
#define AES_DECRYPTION         (0x02)
#define AES_BOTH               (AES_ENCRYPTION | AES_DECRYPTION)



/* ******************************************************************************************* */
/*                                                                                             */
/*   Return Codes for AES routines                                                             */
/*                                                                                             */
/* ******************************************************************************************* */


#define AES_SUCCESS            0
#define AES_INVALID_KEY_SIZE  -1
#define AES_INVALID_MODE      -2



/* ******************************************************************************************* */
/*                                                                                             */
/*   Size definitions used in SHA-1                                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#define SHA1_SCRATCH_BUFFER_SIZE    184
#define SHA1_HASH_SIZE              20



/* ******************************************************************************************* */
/*                                                                                             */
/*   Instruction ROM Jump Table Entries                                                        */
/*                                                                                             */
/* ******************************************************************************************* */

#if defined(__ADSPBF54x__)

#if defined(__SILICON_REVISION__) && (__SILICON_REVISION__==0x1)

#define BFROM_ARC4_INIT       0xFFA14018
#define BFROM_ARC4_CIPHER     0xFFA1401C

#define BFROM_AES_CIPHER      0xFFA14020
#define BFROM_AES_INV_CIPHER  0xFFA14024
#define BFROM_AES_INIT        0xFFA14028
#define BFROM_AES_KEYEXP      0xFFA1402C
#define BFROM_AES_INV_KEYEXP  0xFFA14030

#define BFROM_SHA1_INIT       0xFFA14860
#define BFROM_SHA1_HASH       0xFFA14B6C

#elif defined(__SILICON_REVISION__) && ((__SILICON_REVISION__==0x2) || (__SILICON_REVISION__==0x3) || (__SILICON_REVISION__==0x4))

#define BFROM_ARC4_INIT       0xFFA14018
#define BFROM_ARC4_CIPHER     0xFFA1401C

#define BFROM_AES_CIPHER      0xFFA14020
#define BFROM_AES_INV_CIPHER  0xFFA14024
#define BFROM_AES_INIT        0xFFA14028
#define BFROM_AES_KEYEXP      0xFFA1402C
#define BFROM_AES_INV_KEYEXP  0xFFA14030

#define BFROM_SHA1_INIT       0xFFA14990
#define BFROM_SHA1_HASH       0xFFA14C9C

#else

#define BFROM_ARC4_INIT       __arc4_init
#define BFROM_ARC4_CIPHER     __arc4_cipher

#define BFROM_AES_CIPHER      __aes_cipher
#define BFROM_AES_INV_CIPHER  __aes_inv_cipher
#define BFROM_AES_INIT        __aes_init
#define BFROM_AES_KEYEXP      __aes_keyexp
#define BFROM_AES_INV_KEYEXP  __aes_inv_keyexp

#define BFROM_SHA1_INIT       __sha1_init
#define BFROM_SHA1_HASH       __sha1_hash

#endif /* __SILICON_REVISION__ */

#elif defined(__ADSPBF523__) || defined(__ADSPBF525__) || defined(__ADSPBF527__)

#if defined(__SILICON_REVISION__) && (__SILICON_REVISION__==0x1)

#define BFROM_SHA1_INIT       0xEF001748
#define BFROM_SHA1_HASH       0xEF001A54

#elif defined(__SILICON_REVISION__) && (__SILICON_REVISION__==0x2)

#define BFROM_SHA1_INIT       0xEF001878
#define BFROM_SHA1_HASH       0xEF001B84

#else

#define BFROM_SHA1_INIT       __sha1_init
#define BFROM_SHA1_HASH       __sha1_hash

#endif /* __SILICON_REVISION__ */

#elif defined(__ADSPBF522__) || defined(__ADSPBF524__) || defined(__ADSPBF526__)

#if defined(__SILICON_REVISION__) && (__SILICON_REVISION__==0x0)

#define BFROM_SHA1_INIT       0xEF001748
#define BFROM_SHA1_HASH       0xEF001A54

#elif defined(__SILICON_REVISION__) && ((__SILICON_REVISION__==0x1) || (__SILICON_REVISION__==0x2))

#define BFROM_SHA1_INIT       0xEF001878
#define BFROM_SHA1_HASH       0xEF001B84

#else

#define BFROM_SHA1_INIT       __sha1_init
#define BFROM_SHA1_HASH       __sha1_hash

#endif /* __SILICON_REVISION__ */

#elif defined(__ADSPBF51x__)

#if defined(__SILICON_REVISION__) && ((__SILICON_REVISION__==0x0) || (__SILICON_REVISION__==0x1) || (__SILICON_REVISION__==0x2))

#define BFROM_SHA1_INIT       0xEF001878
#define BFROM_SHA1_HASH       0xEF001B84

#else

#define BFROM_SHA1_INIT       __sha1_init
#define BFROM_SHA1_HASH       __sha1_hash

#endif /* __SILICON_REVISION__ */

#endif /* __ADSPBF5xx__ */

/* ******************************************************************************************* */
/*                                                                                             */
/*   Forward Type Definitions for Relevant Structures as needed for function typedefs below.   */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_BOOT_DATA ADI_BOOT_DATA;
typedef struct ADI_BOOT_BUFFER ADI_BOOT_BUFFER;
typedef struct ADI_BOOT_NAND ADI_BOOT_NAND;

#endif /* _LANGUAGE_C */


/* ******************************************************************************************* */
/*                                                                                             */
/*   Function Variable Types used by bootkernel routines                                       */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef void (ADI_BOOT_HOOK_FUNC) (ADI_BOOT_DATA *) ;
typedef void (ADI_BOOT_LOAD_FUNC) (ADI_BOOT_DATA *) ;
typedef void (ADI_BOOT_ERROR_FUNC) (ADI_BOOT_DATA *, void *) ;
typedef void (ADI_BOOT_INITCODE_FUNC) (ADI_BOOT_DATA *) ;
typedef s32 (ADI_BOOT_CALLBACK_FUNC) (ADI_BOOT_DATA *, ADI_BOOT_BUFFER *, s32 ) ;

#endif /* _LANGUAGE_C */


/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_SYSCTRL structure for syscontrol() routine                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_SYSCTRL_VALUES
{
    u16 uwVrCtl;
    u16 uwPllCtl;
    u16 uwPllDiv;
    u16 uwPllLockCnt;    
    u16 uwPllStat;
    
} ADI_SYSCTRL_VALUES;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_BOOT_HEADER structure for bootkernel routine                                          */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_BOOT_HEADER
{
    s32   dBlockCode;
    void* pTargetAddress;
    s32   dByteCount;
    s32   dArgument;
    
} ADI_BOOT_HEADER; 

#endif /* _LANGUAGE_C */


/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_BOOT_BUFFER structure for boot callback routines                                      */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

/* typedef is above */
struct ADI_BOOT_BUFFER
{
    void*  pSource;
    s32    dByteCount;
    
}; 

#endif /* _LANGUAGE_C */


/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_BOOT_DATA structure for bootkernel routine                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

/* typedef is above */
struct ADI_BOOT_DATA
{
    void  *pSource;
    void  *pDestination;
    u16   *pControlRegister;
    u16   *pDmaControlRegister;
    s32    dControlValue;
    s32    dByteCount;
    s32    dFlags;
    u16    uwDataWidth;
    u16    uwSrcModifyMult;
    u16    uwDstModifyMult;
    u16    uwHwait;
    u16    uwSsel;
    u16    uwUserShort;
    s32    dUserLong;
    s32    dReserved;
 
    ADI_BOOT_ERROR_FUNC *pErrorFunction;
    ADI_BOOT_LOAD_FUNC *pLoadFunction;
    ADI_BOOT_CALLBACK_FUNC *pCallBackFunction;
    ADI_BOOT_HEADER *pHeader;
    void  *pTempBuffer;
    void  *pTempCurrent;
    s32    dTempByteCount;
    s32    dBlockCount;
    s32    dClock;

    void  *pLogBuffer;
    void  *pLogCurrent;
    s32    dLogByteCount;
    
}; 


#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_BOOT_DATA structure for NAND boot routines                                            */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)


typedef struct ADI_BOOT_NAND_BUFFER
{
    void *pBegin;
    u16 uwLoadedNFCPage;
    u16 uwLoadedNANDPage;
    u16 uwLoadedNANDBlock;    
    
} ADI_BOOT_NAND_BUFFER;


typedef struct ADI_BOOT_NAND_ACCESS
{
    u16 uwAccessNFCPage;
    u16 uwAccessNANDPage;
    u16 uwAccessNANDBlock;    
    
} ADI_BOOT_NAND_ACCESS;


typedef struct ADI_BOOT_NAND_DEVICE
{
    u32 udIdCode;
    u32 udType;
    u16 uwBusWidth;
    u16 uwColumnMaskCount;
    u32 udColumnMask;
    u16 uwPageMaskCount;
    u32 udPageMask;
    u16 uwSpareMaskCount;
    u16 uwSpareAreaBit;
    u32 udBlockSize;
    u16 uwPageSize;
    u16 uwPagesPerBlock;
    u16 uwSpareAreaSize;
    u16 uwSpareAreaModifier;
    u16 uwNFCPages;   
     
} ADI_BOOT_NAND_DEVICE;


typedef struct ADI_BOOT_NAND_ADDRESS
{
    void *pSource;
    u32 udMainOffset;
    u32 udPrefetchOffset;
    u16 uwNumAddressCycles;
    u16 uwNumCommandCycles;
    u16 uwSerialAccess;
    ADI_BOOT_NAND * pNandInfo;
    #pragma align 4
    u8 ubCommand0;
    u8 ubAddress0;
    u8 ubAddress1;
    u8 ubAddress2;
    u8 ubAddress3;
    u8 ubAddress4;
    u8 ubCommand1;    

} ADI_BOOT_NAND_ADDRESS;


typedef struct ADI_BOOT_NAND_ECC
{
    #pragma align 4
    u16 uwIndex;
    u32 udNFCParity[32];
    u16 uwError;
    u16 uwBlockSkipFeature;
    u16 uwBlockModifier;
    u16 uwMaxCopies;
    u16 uwCurrentCopy;    
    
} ADI_BOOT_NAND_ECC;


/* typedef is above */
struct ADI_BOOT_NAND
{
    ADI_BOOT_NAND_DEVICE DeviceInfo;
    ADI_BOOT_NAND_BUFFER MainBuffer;
    ADI_BOOT_NAND_BUFFER PrefetchBuffer;
    ADI_BOOT_NAND_ACCESS AddressRequested;
    ADI_BOOT_NAND_ADDRESS AddressCycles;
    ADI_BOOT_NAND_ECC EccParity;  
    ADI_BOOT_DATA *pBootData;
    void *pReserved;
    
};


#endif


/* ******************************************************************************************* */
/*                                                                                             */
/*   Structures used by the the boot code internally                                           */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)


typedef struct ADI_BOOT_LOCAL
{
    s32    dHeaderSize;
    s32    dAction;
    void  *pTempBuffer;
    s32    dTempByteCount;
    
} ADI_BOOT_LOCAL; 


typedef struct ADI_BOOT_GPIO
{
    u16  *pDirClearReg;
    u16  *pAssertReg;
    u16  *pDeassertReg;
    s32   dFlags;
    
} ADI_BOOT_GPIO; 


#endif



/* ******************************************************************************************* */
/*                                                                                             */
/*   Preboot User Settings (PBS) structure                                                     */
/*                                                                                             */
/*   Defines bit fields of USER settings block see section OTP Memory pages for booting        */
/*   in the System Reset and Booting Chapter of the hardware reference manual-                 */
/*   NOTE: bitfield names omit the "OTP_" prefix and are converted to lower case with respect  */
/*   to the names in the manual                                                                */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_PBS_BITFIELDS
{
    
    /* *** OTP page PBS00L *** */
    u16 vr_ctl                ;    /* [15: 0] */
    u16 pll_ctl               ;    /* [31:16] */
    u16  pll_div            : 8;    /* [39:32] */
    u16  spi_baud           : 3;    /* [42:40] */
    u16  spi_fastread       : 1;    /* [43]    */
    u16  twi_clkdiv         : 1;    /* [44]    */
    u16  twi_prescale       : 3;    /* [47:45] */
    u16  twi_type           : 2;    /* [49:48] */
    u16  set_pll            : 1;    /* [50]    */
    u16  set_vr             : 1;    /* [51]    */
    u16  resetout_hwait     : 1;    /* [52]    */
    
    
#if defined(__ADSPBF54x__)

    u16  alternate_hwait    : 1;    /* [53]    */
    u16                     : 1;    /* [54]    reserved */       

#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    u16                     : 2;    /* [54:53] reserved */

#endif

    
    u16  load_pbs00h        : 1;    /* [55]    */
    u16  load_pbs01l        : 1;    /* [56]    */
    u16  load_pbs01h        : 1;    /* [57]    */
    u16  load_pbs02l        : 1;    /* [58]    */
    u16  load_pbs02h        : 1;    /* [59]    */
    u16  load_pbs03l        : 1;    /* [60]    */
    u16  load_pbs03h        : 1;    /* [61]    */    
    u16  invalid            : 2;    /* [63:62] */
    

    /* *** OTP page PBS00H *** */
    
    u16 ebiu_ambctl           ;    /* [15:0]  */
    
#if defined(__ADSPBF54x__)    
    
    u16 ebiu_fctl              ;    /* [31:16] */
    u16  ebiu_mode           :8;    /* [39:32] */
    
#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    u16                     :16;    /* [31:16] reserved */
    u16                     : 8;    /* [39:32] reserved */

#endif        
    
    u16  ebiu_amg           : 4;    /* [43:40] */


#if defined(__ADSPBF54x__)            

    u16  ebiu_devseq        : 4;    /* [47:44] */
    u16 ebiu_devcfg           ;    /* [63:48] */

#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    u32                    : 20;   /* [63:44] reserved */

#endif        
    
    
   /* *** OTP page PBS01L *** */

   u64                     : 64;   /* [63:0] reserved */
   
   
   /* *** OTP page PBS01H *** */

    u16  bmode00_dis        : 1;   /* [0]      */
    u16  bmode01_dis        : 1;   /* [1]      */
    u16  bmode02_dis        : 1;   /* [2]      */
    u16  bmode03_dis        : 1;   /* [3]      */
    u16  bmode04_dis        : 1;   /* [4]      */
    u16  bmode05_dis        : 1;   /* [5]      */
    u16  bmode06_dis        : 1;   /* [6]      */
    u16  bmode07_dis        : 1;   /* [7]      */
    u16  bmode08_dis        : 1;   /* [8]      */
    u16  bmode09_dis        : 1;   /* [9]      */
    u16  bmode10_dis        : 1;   /* [10]     */
    u16  bmode11_dis        : 1;   /* [11]     */
    u16  bmode12_dis        : 1;   /* [12]     */
    u16  bmode13_dis        : 1;   /* [13]     */
    u16  bmode14_dis        : 1;   /* [14]     */
    u16  bmode15_dis        : 1;   /* [15]     */    
    u16  nfc_ctl            : 8;   /* [23:16]  */
    u16  start_page         : 8;   /* [31:24]  */
    u32                     :32;   /* [63:32] reserved */
    
    
    /* *** OTP page PBS02L *** */
    
#if defined(__ADSPBF54x__)

    u32 ebiu_ddrctl0          ;  /* [31:0]   */
    u32 ebiu_ddrctl1          ;  /* [63:32]  */
    
#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    u32 ebiu_sdgctl            ;  /* [31:0]   */
    u16 ebiu_sdbctl            ;  /* [47:32]  */
    u16 ebiu_sdrcc         : 12;  /* [59:48]  */
    u16                     : 3 ;  /* [62:60] reserved */
    u16  ebiu_poweron_dummy_write: 1; /* [63]  */
    
#endif

    /* *** OTP page PBS02H *** */

#if defined(__ADSPBF54x__)

    u16 ebiu_ddrctl2l          ;  /* [15:0]   */
    u16 ebiu_ddrctl3l          ;  /* [31:16]  */    
    u16 ebiu_ddrquel           ;  /* [47:32]  */
    u16                    : 16;  /* [63:48] reserved */
    
#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__)

    u64                    : 64;  /* [63:0] reserved */
    
#endif

    /* *** OTP page PBS03L *** */
    
    u64                    : 64;  /* [63:0] reserved */
    
    /* *** OTP page PBS03H *** */
    
    u64                    : 64;  /* [63:0] reserved */
    
} ADI_PBS_BITFIELDS;



typedef struct ADI_PBS_HALFPAGES
{
    u64 uqPbs00L;
    u64 uqPbs00H;
    u64 uqPbs01L;
    u64 uqPbs01H;
    u64 uqPbs02L;
    u64 uqPbs02H;
    u64 uqPbs03L;
    u64 uqPbs03H;
    
} ADI_PBS_HALFPAGES;



typedef union ADI_PBS_BLOCK
{
   ADI_PBS_BITFIELDS BitFields;
   ADI_PBS_HALFPAGES HalfPages;
   
} ADI_PBS_BLOCK;



#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_AES_DATA structure for AesInit() routine                                              */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_AES_DATA
{
  u32  *pKeyExpTmp;
  u32  *pKR;
  u32  *pState;
  u32  *pIV;
  u32  *pRcon;
  u16  *pStateShiftExtract;
  u16  *pInvStateShiftExtract;
  u8   *pSBox;
  u8   *pSBoxMixC;
  u8   *pGFMpyTbl;
  u8   *pInvSBox;
  u8   *pInvSBoxMixC;
  u32  *pStatePointers;
  
} ADI_AES_DATA;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_AES_KEYEXPANSION structure for AesKeyexp and AesInvKeyexp() routines                  */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_AES_KEYEXPANSION
{
  u8            *pCipherKey;
  u8            *pRoundKeys;
  u32           udKeySize;
  ADI_AES_DATA  *pAesData;

} ADI_AES_KEYEXPANSION;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_AES_CIPHER structure for AesCipher and AesInvCipher() routines                        */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_AES_CIPHER {
  u8            *pInputData;
  u8            *pOutputData;
  u8            *pRoundKeys;
  u32           udDataLength;
  u8            *pInitVector;
  u32           udKeySize;
  u32           udMode;
  ADI_AES_DATA  *pAesData;

} ADI_AES_CIPHER;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_SHA1 structure for Sha1Init and Sha1Hash() routines                                   */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_SHA1 {
  u8   *pInputMessage;
  u32  udMessageSize;
  u8   *pOutputDigest;
  u8   *pScratchBuffer;

} ADI_SHA1;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_ARC4_KEY structure for Arc4Init() routine                                             */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct  ADI_ARC4_KEY {
  u32  *pSBox;
  u32  *pKey;
  u32  udKeyLength;

} ADI_ARC4_KEY;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   ADI_ARC4_DATA structure for Arc4Cipher() routine                                          */
/*                                                                                             */
/* ******************************************************************************************* */


#if defined (_LANGUAGE_C)

typedef struct ADI_ARC4_DATA {
  u32    *pSBox;
  u32    *pData;
  u32    udDataLength;

} ADI_ARC4_DATA;

#endif /* _LANGUAGE_C */



/* ******************************************************************************************* */
/*                                                                                             */
/*   C Prototypes of API functions                                                             */
/*                                                                                             */
/* ******************************************************************************************* */


#ifdef __cplusplus
extern "C" {
#endif



#if defined (_LANGUAGE_C)

#pragma inline
#pragma always_inline
static u32 bfrom_SysControl(u32 dActionFlags, ADI_SYSCTRL_VALUES *pSysCtrlSettings, void *reserved)
{
   u32 (*pSysControl)(u32 dActionFlags, ADI_SYSCTRL_VALUES *pSysCtrlSettings, void *reserved)= 
      (u32 (*)(u32 dActionFlags, ADI_SYSCTRL_VALUES* pSysCtrlSettings, void *reserved))(BFROM_SYSCONTROL);
   return (*pSysControl)(dActionFlags, pSysCtrlSettings, reserved);
}

#pragma inline
#pragma always_inline
static u32 bfrom_OtpRead (u32 dPage, u32 dFlags, u64 *pPageContent)
{
   u32 (*pOtpRead)(u32 dPage, u32 dFlags, u64 *pPageContent) = (u32 (*)(u32 dPage, u32 dFlags, u64 *pPageContent))(BFROM_OTP_READ);
   return (*pOtpRead)(dPage, dFlags, pPageContent);
}

#pragma inline
#pragma always_inline
static u32 bfrom_OtpWrite (u32 dPage, u32 dFlags, u64 *pPageContent)
{
   u32 (*pOtpWrite)(u32 dPage, u32 dFlags, u64 *pPageContent) = (u32 (*)(u32 dPage, u32 dFlags, u64 *pPageContent))(BFROM_OTP_WRITE);
   return (*pOtpWrite)(dPage, dFlags, pPageContent);
}

#pragma inline
#pragma always_inline
static u32 bfrom_OtpCommand(u32 dCommand, u32 dValue)
{
   u32  (*pOtpCommand)(u32 dCommand, u32 dValue) = (u32 (*)(u32 dCommand, u32 dValue))(BFROM_OTP_COMMAND);
   return (*pOtpCommand)(dCommand, dValue);
}

#pragma inline
#pragma always_inline
static void bfrom_FinalInit(void)
{
    void (*pFinalInit)()= 
      (void (*)())(BFROM_FINALINIT);
   (*pFinalInit)();
}

#pragma inline
#pragma always_inline
static void bfrom_PDma(ADI_BOOT_DATA *pBootStruct)
{
    void (*pPDma)(ADI_BOOT_DATA *pBootStruct) =
        (void (*)(ADI_BOOT_DATA *pBootStruct))(BFROM_PDMA);
    (*pPDma)(pBootStruct);    
}

#pragma inline
#pragma always_inline
static void bfrom_MDma(ADI_BOOT_DATA *pBootStruct)
{
    void (*pMDma)(ADI_BOOT_DATA *pBootStruct) =
        (void (*)(ADI_BOOT_DATA *pBootStruct))(BFROM_MDMA);
    (*pMDma)(pBootStruct);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_BootKernel(ADI_BOOT_DATA *pBootStruct)
{
    s32 (*pBootKernel)(ADI_BOOT_DATA *pBootStruct) =
        (s32 (*)(ADI_BOOT_DATA *pBootStruct))(BFROM_BOOTKERNEL);
    return (*pBootKernel)(pBootStruct);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_MemBoot(void* pBootStream, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook)
{
    s32 (*pMemBoot)(void *pBootStream, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook) =
        (s32 (*)(void *pBootStream, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook))(BFROM_MEMBOOT);
    return (*pMemBoot)(pBootStream, dFlags, dBlockCount, pCallHook);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_TwiBoot(s32 dTwiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook)
{
    s32 (*pTwiBoot)(s32 dTwiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook) =
        (s32 (*)(s32 dTwiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook))(BFROM_TWIBOOT);
    return (*pTwiBoot)(dTwiAddress, dFlags, dBlockCount, pCallHook);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_SpiBoot(s32 dSpiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook)
{
    s32 (*pSpiBoot)(s32 dSpiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook) =
        (s32 (*)(s32 dSpiAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook))(BFROM_SPIBOOT);
    return (*pSpiBoot)(dSpiAddress, dFlags, dBlockCount, pCallHook);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_OtpBoot(s32 dOtpAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook)
{
    s32 (*pOtpBoot)(s32 dOtpAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook) =
        (s32 (*)(s32 dOtpAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook))(BFROM_OTPBOOT);
    return (*pOtpBoot)(dOtpAddress, dFlags, dBlockCount, pCallHook);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_NandBoot(s32 dNandAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook)
{
    s32 (*pNandBoot)(s32 dNandAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook) =
        (s32 (*)(s32 dNandAddress, s32 dFlags, s32 dBlockCount, ADI_BOOT_HOOK_FUNC *pCallHook))(BFROM_NANDBOOT);
    return (*pNandBoot)(dNandAddress, dFlags, dBlockCount, pCallHook);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_Crc32(s32 *pLut, void *pData, s32 dByteCount, s32 dInitial)
{
    s32 (*pCrc32)(s32 *pLut, void *pData, s32 dByteCount, s32 dInitial) =
        (s32 (*)(s32 *pLut, void *pData, s32 dByteCount, s32 dInitial))(BFROM_CRC32);
    return (*pCrc32)(pLut, pData, dByteCount, dInitial);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_Crc32Poly(s32 *pLut, s32 dPolynomial)
{
    s32 (*pCrc32Poly)(s32 *pLut, s32 dPolynomial) =
        (s32 (*)(s32 *pLut, s32 dPolynomial))(BFROM_CRC32POLY);
    return (*pCrc32Poly)(pLut, dPolynomial);    
}

#pragma inline
#pragma always_inline
static void bfrom_Crc32Initcode(ADI_BOOT_DATA *pBootStruct)
{
    void (*pCrc32Initcode)(ADI_BOOT_DATA *pBootStruct) =
        (void (*)(ADI_BOOT_DATA *pBootStruct))(BFROM_CRC32INITCODE);
    (*pCrc32Initcode)(pBootStruct);    
}

#pragma inline
#pragma always_inline
static s32 bfrom_Crc32Callback(ADI_BOOT_DATA *pBootStruct, 
                               ADI_BOOT_BUFFER *pBufferStruct, 
                               s32 dCbFlags)
{
    ADI_BOOT_CALLBACK_FUNC *pCrc32Callback = 
                                 (ADI_BOOT_CALLBACK_FUNC*)(BFROM_CRC32CALLBACK);
    return (*pCrc32Callback)(pBootStruct, pBufferStruct, dCbFlags);    
}

#pragma inline
#pragma always_inline
static void bfrom_GetPort(ADI_BOOT_GPIO *pGpioStruct, s32 dGpio)
{
    void (*pGetPort)(ADI_BOOT_GPIO *pGpioStruct, s32 dGpio) =
        (void (*)(ADI_BOOT_GPIO *pGpioStruct, s32 dGpio))(BFROM_GETPORT);
    (*pGetPort)(pGpioStruct, dGpio);    
}

#if defined(__ADSPBF50x__)
#pragma inline
#pragma always_inline
static void bfrom_FlashProtect(u32 dArgument)
{
  void (*pFlashProtect)(u32 dArgument) =
    (void (*)(u32 dArgument))(BFROM_FLASHPROTECT);
  (*pFlashProtect)(dArgument);
}

#pragma inline
#pragma always_inline
static void bfrom_FlashProtectInitcode(ADI_BOOT_DATA *pBootStruct)
{
  void (*pFlashProtectInitcode)(ADI_BOOT_DATA *pBootStruct) =
    (void (*)(ADI_BOOT_DATA *pBootStruct))(BFROM_FLASHPROTECTINITCODE);
  (*pFlashProtectInitcode)(pBootStruct);
}
#endif /* __ADSPBF50x__ */

#endif /* _LANGUAGE_C */

#ifdef __cplusplus
}
#endif


/* ******************************************************************************************* */
/*                                                                                             */
/*   C Prototypes of API functions in Instruction ROM                                          */
/*                                                                                             */
/* ******************************************************************************************* */

#ifdef __cplusplus
extern "C" {
#endif

#if defined (_LANGUAGE_C)

void __sha1_hash(ADI_SHA1 *pSha1);
void __sha1_init(u8 *pScratchBuffer);
void __arc4_init(ADI_ARC4_KEY *pArc4Key);
s32 __aes_inv_cipher(ADI_AES_CIPHER *pAesCipherData);
s32 __aes_cipher(ADI_AES_CIPHER *pAesCipherData);
void __aes_init(u32 udFlags, ADI_AES_DATA *pAesData);
s32 __aes_keyexp(ADI_AES_KEYEXPANSION *pAesKeyexpData);
s32 __aes_inv_keyexp(ADI_AES_KEYEXPANSION *pAesKeyexpData);
void __arc4_cipher(ADI_ARC4_DATA *pArc4Data);

#if defined(__ADSPBF54x__)

#pragma inline
#pragma always_inline
static void bfrom_AesInit (u32 udFlags, ADI_AES_DATA *pAesData)
{
    void (*pAesInit)(u32 udFlags, ADI_AES_DATA *pAesData) =
        (void (*)(u32 udFlags, ADI_AES_DATA *pAesData))(BFROM_AES_INIT);
    (*pAesInit)(udFlags, pAesData);
}

#pragma inline
#pragma always_inline
static s32 bfrom_AesKeyexp (ADI_AES_KEYEXPANSION *pAesKeyexpData)
{
    s32 (*pAesKeyexp)(ADI_AES_KEYEXPANSION *pAesKeyexpData) =
        (s32 (*)(ADI_AES_KEYEXPANSION *pAesKeyexpData))(BFROM_AES_KEYEXP);
    return (*pAesKeyexp)(pAesKeyexpData);
}

#pragma inline
#pragma always_inline
static s32 bfrom_AesInvKeyexp (ADI_AES_KEYEXPANSION *pAesKeyexpData)
{
    s32 (*pAesInvKeyexp)(ADI_AES_KEYEXPANSION *pAesKeyexpData) =
        (s32 (*)(ADI_AES_KEYEXPANSION *pAesKeyexpData))(BFROM_AES_INV_KEYEXP);
    return (*pAesInvKeyexp)(pAesKeyexpData);
}

#pragma inline
#pragma always_inline
static s32 bfrom_AesCipher (ADI_AES_CIPHER *pAesCipherData)
{
    s32 (*pAesCipher)(ADI_AES_CIPHER *pAesCipherData) =
        (s32 (*)(ADI_AES_CIPHER *pAesCipherData))(BFROM_AES_CIPHER);
    return (*pAesCipher)(pAesCipherData);
}

#pragma inline
#pragma always_inline
static s32 bfrom_AesInvCipher (ADI_AES_CIPHER *pAesCipherData)
{
    s32 (*pAesInvCipher)(ADI_AES_CIPHER *pAesCipherData) =
        (s32 (*)(ADI_AES_CIPHER *pAesCipherData))(BFROM_AES_INV_CIPHER);
    return (*pAesInvCipher)(pAesCipherData);
}

#pragma inline
#pragma always_inline
static void bfrom_Arc4Init (ADI_ARC4_KEY *pArc4Key)
{
    void (*pArc4Init)(ADI_ARC4_KEY *pArc4Key) =
        (void (*)(ADI_ARC4_KEY *pArc4Key))(BFROM_ARC4_INIT);
    (*pArc4Init)(pArc4Key);
}

#pragma inline
#pragma always_inline
static void bfrom_Arc4Cipher (ADI_ARC4_DATA *pArc4Data)
{
    void (*pArc4Cipher)(ADI_ARC4_DATA *pArc4Data) =
        (void (*)(ADI_ARC4_DATA *pArc4Data))(BFROM_ARC4_CIPHER);
    (*pArc4Cipher)(pArc4Data);
}

#endif /* __ADSPBF54x__ */

#if defined(__ADSPBF54x__) || defined(__ADSPBF523__) || \
    defined(__ADSPBF525__) || defined(__ADSPBF527__) || \
    defined(__ADSPBF522__) || defined(__ADSPBF524__) || \
    defined(__ADSPBF526__) || defined(__ADSPBF51x__)

#pragma inline
#pragma always_inline
static void bfrom_Sha1Init (u8 *pScratchBuffer)
{
    void (*pSha1Init)(u8 *pScratchBuffer) =
        (void (*)(u8 *pScratchBuffer))(BFROM_SHA1_INIT);
    (*pSha1Init)(pScratchBuffer);
}

#pragma inline
#pragma always_inline
static void bfrom_Sha1Hash (ADI_SHA1 *pSha1)
{
    void (*pSha1Hash)(ADI_SHA1 *pSha1) =
        (void (*)(ADI_SHA1 *pSha1))(BFROM_SHA1_HASH);
    (*pSha1Hash)(pSha1);
}

#endif /* __ADSPBF54x__, __ADSPBF523__, etc. */

#endif /* _LANGUAGE_C */

#ifdef __cplusplus
}
#endif

#ifdef _MISRA_RULES
#pragma diag(pop)
#endif /* _MISRA_RULES */

#endif /* _BFROM_H */

