/*****************************************************************************
 *
 * twidfftrad2_fr32 : $Revision: 1.6 $
 *
 * (c) Copyright 2008-2010 Analog Devices, Inc.  All rights reserved.
 *
 *****************************************************************************/

#if defined(__DOCUMENTATION__)

    Function: twidfftrad2_fr32 - twiddle factor generator

    Synopsis:

        #include <filter.h>
        void twidfftrad2_fr32 (complex_fract32  twiddle_table[],
                               int              fft_size); 

    Description:

        The twidfftrad2_fr32 function calculates complex twiddle coefficients
        for an FFT of size fft_size and returns the coefficients in the vector
        twiddle_table. The size of the vector, which is known as twiddle table,
        must be at least fft_size/2. It contains pairs of sine and cosine
        values that are used by an FFT function to calculate a Fast Fourier
        Transform. The table generated by this function may be used by any
        of the FFT functions cfft_fr32, ifft_fr32, and rfft_fr32.

        A twiddle table of a given size will contain constant values, and
        so typically such a table would be generated only once during the
        development cycle of an application and would thereafter be preserved
        by the application in some suitable form.

        An application that calculates FFTs of different sizes does not require
        multiple twiddle tables. A single twiddle table can be used to compute
        the FFTs provided that the table is created for the largest FFT that
        the application expects to generate. Each of the FFT functions cfft,
        ifft, and rfft have a twiddle stride argument that the application
        would set to 1 when it is generating an FFT with the largest number
        of data points. To generate smaller FFTs, the twiddle stride argument
        should be set according to the formula:

            largest FFT size
            ----------------
            current FFT size

        For example, if an twiddle table had been created for a 1024-point
        FFT, then the same table could also be used to calculate a 256-point
        FFT by setting the twiddle stride argument to 4.

    Error Conditions:

        The twidfftrad2_fr32 function does not return an error condition.

    Algorithm:

        twiddle_table[k].re =  cos( 2 * PI * k / fft_size )
        twiddle_table[k].im = -sin( 2 * PI * k / fft_size )

            where k = 0, .., (fft_size/2 - 1)

    Implementation:

        Since the FFT size can be assumed to be a power of 2,
        the computation (fract32) 1 / (fft_size / 4) can be performed 
        using a shift operation:

            nquart = (fft_size / 4); 
            reciprocal =  nquart << ((2 * signbits(nquart)) - 31)

        with the norm instruction returning signbits - 1:  

            reciprocal =  nquart << ((2 * signbits(nquart)) - 29)

    Example:

        #include <filter.h>
        #define FFT_SIZE1   256
        #define FFT_SIZE2    64
        #define TWID_SIZE   (FFT_SIZE1/2)

        complex_fract32  input1[FFT_SIZE1];
        complex_fract32  output1[FFT_SIZE1];
        complex_fract32  input2[FFT_SIZE2];
        complex_fract32  output2[FFT_SIZE2];
        complex_fract32  twiddles[TWID_SIZE];
        int   block_exponent1, block_exponent2;
        int   scale_method = 1;

        twidfftrad2_fr32 (twiddles, FFT_SIZE1);

        cfft_fr32 (input1, output1, twiddles, 
                   1, FFT_SIZE1,
                   &block_exponent1, scale_method);

        cfft_fr32 (input2, output2, twiddles,
                   (FFT_SIZE1/FFT_SIZE2), FFT_SIZE2,
                   &block_exponent2, scale_method);

*****************************************************************************
#endif

#if !defined(__NO_LIBRARY_ATTRIBUTES__)
#pragma file_attr ("libGroup =filter.h")
#pragma file_attr ("libName  =libdsp")
#pragma file_attr ("libFunc  =twidfftrad2_fr32")
#pragma file_attr ("libFunc  =__twidfftrad2_fr32")
#pragma file_attr ("prefersMem =external")
#pragma file_attr ("prefersMemNum =70")
   /* (Use prefersMem=external because the function
   **  is usually called no more than once)
   */
#endif

#if !defined(TRACE)
#pragma optimize_for_space
#endif

#ifdef _MISRA_RULES
#pragma diag(suppress:misra_rule_6_3)
/* Suppress Rule 6.3 (advisory) whereby typedefs that indicate
** size and signedness should be used in place of the basic types.
**
** Rationale: The C/C++ manual documents the prototypes of the library
** functions using the intrinsic C data types and these prototypes must
** correspond to the actual prototypes that are defined in the header
** files. In addition, Rule 8.3 requires that the type of the result
** and the type of the parameters that are specified in a function
** definition and a function declaration are identical.
*/

#pragma diag(suppress:misra_rule_17_4)
/* Suppress Rule 17.4 (required) which stipulates that array indexing is
** the only acceptable form of pointer arithmetic, and that pointers may
** not be referred to as an array.
**
** Rationale: Each library function adhers to MISRA Rule 16.4 whereby
** the identifiers used in the declaration and definition of a function
** shall be identical. Because of the requirements of C, this means that
** the names of the parameters must begin with a underscore. Each library
** function will then always copy each parameter to a local variable with
** an identical name apart from the leading underscore. For parameters that
** are arrays this means that the corresponding local scalar has to be declared
** as a pointer and therefore any array indexing off this pointer will violate
** MISRA Rule 17.4 although it is clear from the source that the pointer
** is associated with an array.
*/
#endif /* _MISRA_RULES */

#include <filter.h>
#include <math.h>

extern void
twidfftrad2_fr32( complex_fract32 _twiddle_table[],
                  int             _fft_size )
{

    /* local copies of the arguments */
    complex_fract32 * const  twiddle_table = _twiddle_table;
    const int                fft_size      = _fft_size;
       
    int        j, idx_q1, idx_q2;
    const int  nquart = shl_i1x32( fft_size, -2 );
    fract32    cos_val, sin_val, val, step;

    short      signbits;  /* number of leading sign bits in nquart */

    /* determine step size between samples (= 1/nquart) */
    signbits   = norm_fr1x32( nquart );
    step       = shl_fr1x32( nquart, (2 * signbits) - 29 );
    val        = 0;

    /* initialize indices 
    ** (first element in 1. quadrant and last element in 2. quadrant
    */
    idx_q1 = 0;
    idx_q2 = shl_i1x32( fft_size, -1 );
 
    /* 1. quadrant
    ** Compute cosine and -sine values for the range [0..PI/2)
    ** 2. quadrant
    ** Exploit symmetry of sine and cosine function:
    **    cos(pi - x) = -cos(x),  sin(pi - x) = sin(x)
    */
    twiddle_table[idx_q1].re = (fract32) 0x7fffffff;  /* = cos( 0 ) */
    twiddle_table[idx_q1].im = (fract32) 0x0;         /* = sin( 0 ) */

#pragma loop_count(2,,2) 
#pragma extra_loop_loads
#pragma vector_for
    for (j = 1; j < nquart; j++)
    {
        idx_q1++;
        idx_q2--;

        val = add_fr1x32( val, step ); 

        cos_val = cos_fr32( val );
        twiddle_table[idx_q1].re =  cos_val;
        twiddle_table[idx_q2].re = -cos_val;

        sin_val = -sin_fr32( val );
        twiddle_table[idx_q1].im =  sin_val;
        twiddle_table[idx_q2].im =  sin_val;
    }

    twiddle_table[nquart].re = (fract32) 0x0;          /* =  cos( PI/2 ) */
    twiddle_table[nquart].im = (fract32) 0x80000000;   /* = -sin( PI/2 ) */
}

/* End of File */
