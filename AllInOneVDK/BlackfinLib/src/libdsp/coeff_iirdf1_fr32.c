/****************************************************************************
 *
 * coeff_iirdf1_fr32.c : $ Revision: $
 *
 * (c) Copyright 2007-2010 Analog Devices, Inc.  All rights reserved.
 *
 ***************************************************************************/

#if defined(__DOCUMENTATION__)

    Function: coeff_iirdf1_fr32 - convert coefficients for DF1 IIR filter 

    Synopsis:

        #include <filter.h>
        void coeff_iirdf1_fr32 (const long double acoeff[],
                                const long double bcoeff[],
                                fract32           coeff[],
                                int               nstages);

    Description:

        The coeff_iirdf1_fr32 function transforms a set of A-coefficients and
        a set of B-coefficients into a set of coefficients for the iirdf1_fr32
        function, which implements a direct form 1 infinite impulse response
        (IIR) filter.

        The A-coefficients and the B-coefficients are passed into the function
        via the floating-point vectors acoeff and bcoeff, respectively. The A0
        coefficient is assumed to be 1.0, and all other A-coefficients must be
        scaled according; the A0 coefficient should not be included in the
        acoeffs vector. The number of stages in the filter is given by the
        parameter nstages, and therefore the size of the acoeffs vector is
        2*nstages and the size of the bcoeffs vector is (2*nstages) + 1. The
        A-coefficients and B-coefficients must be supplied in transfer function
        representation if the number of stages is greater than one.

        The values of the coefficients that are held in the vectors acoeffs and
        bcoeffs must be in the range of [LONG_MIN, LONG_MAX], that is they must
        not be less than -2147483648, or greater than 2147483647.

        The coeff_iirdf1_fr32 function scales the coefficients and stores them
        in the vector coeff. The function also stores the appropriate scaling
        factor in the vector which the iirdf1_fr32 function will then apply to
        the filtered response that it generates (thus eliminating the need to
        scale the output generated by the IIR function). The size of the
        coeffs array should be (4*nstages) + 2.

        Note: Be aware of the consequence of specifying a set of filter
        coefficients whose order of magnitude are significantly different.
        "Significantly" refers to an order of magnitude greater than or equal
        to 31 when expressed as a power of 2. In this situation, one or more
        filter coefficients may be transformed to zero due to the precision
        of the fract32 type, and this may affect the performance of the filter.

    Error Conditions:

        The coeff_iirdf1_fr32 function will not transform the set of
        A-coefficients and the set of B-coefficients if the parameter
        nstages is not positive.

    Algorithm:

        If any of the coefficients are greater than or equal to 1.0, then all
        the A-coefficients and all the B-coefficients are scaled to be less
        than 1.0. The coefficients are stored in the vector coeffs in the
        following order:

        coeff[k] = { bcoeff[0], -acoeff[1],
                     bcoeff[1], -acoeff[2],
                     bcoeff[2], -acoeff[3],
                     bcoeff[3], ...
                           ..., -acoeff[n],
                     bcoeff[m],  scaling_factor
                   }

        where n = 2*nstages
              m = 2*nstages+1
              k = 0..(4*nstages+1)

        Note that the A-coefficients are negated by the function.
        The scaling factor is assumed to be a power of two.

    Implementation:

        1) Find the largest coefficient (A-coefficients and B-coefficients)
           supplied

        2) Extract the exponent (base 2) of the largest coefficient
           ( == scaling_factor )

        3) Convert the B-coefficients to fixed point

                                   bcoeff[i]
           coeff[2*i] = ------------------------------ * 2^31 (=2147483648)
                        2^k (k=exponent largest coeff)

                      = bcoeff[i] * (2^31 / 2^k)  

                      = bcoeff[i] * 2^(31 - k) 

           and convert the A-coefficients to fixed point

                                  (-1) * acoeff[i]
           coeff[(2*i)+1] = ------------------------------ * 2^31 (=2147483648)
                            2^k (k=exponent largest coeff)

                          = -acoeff[i] * (2^31 / 2^k)

                          = -acoeff[i] * 2^(31 - k)
                                   
        5) Store the scaling_factor in coeff[(4*nstages+1)]
 
    Example:

        #include <filter.h>
        #include <vector.h>

        #define NSAMPLES 50
        #define NSTAGES 2

        /* Coefficients for the coeff_iirdf1_fr32 function */

        long double a_coeffs[(2 * NSTAGES)] = { . . . };
        long double b_coeffs[(2 * NSTAGES) + 1] = { . . . };

        /* Coefficients for the iirdf1_fr32 function */

        fract32 df1_coeffs[(4 * NSTAGES) + 2];

        /* Input, Output, Delay Line, and Filter State */

        fract32 input[NSAMPLES], output[NSAMPLES];
        fract32 delay[(4 * NSTAGES) + 2];
        iirdf1_state_fr32 state;

        long double gain;
        int i;

        /* Initialize filter description */

        iirdf1_init (state,df1_coeffs,delay,NSTAGES);

        /* Initialize the delay line */

        for (i = 0; i < ((4 * NSTAGES) + 2); i++)
            delay[i] = 0;  

        /* Convert coefficients */

        if (gain >= 1.0L)
            vecsmltd (b_coeffs,(1.0L/gain),b_coeffs,((2*NSTAGES)+1));

        coeff_iirdf1_fr32 (a_coeffs,b_coeffs,df1_coeffs,NSTAGES);

        /* Call the direct form I IIR filter function */

        iirdf1_fr32 (input,output,NSAMPLES,&state);

*****************************************************************************
#endif

#if !defined(__NO_LIBRARY_ATTRIBUTES__)

#pragma file_attr("libGroup =filter.h")
#pragma file_attr("libFunc  =coeff_iirdf1_fr32")
#pragma file_attr("libFunc  =__coeff_iirdf1_fr32")
#pragma file_attr("libName  =libdsp")
#pragma file_attr("prefersMem =internal")
#pragma file_attr("prefersMemNum =30")

#endif

#if !defined(TRACE)
#pragma optimize_for_speed
#endif

#ifdef _MISRA_RULES
#pragma diag(suppress:misra_rule_6_3)
/* Suppress Rule 6.3 (advisory) whereby typedefs that indicate
** size and signedness should be used in place of the basic types.
**
** Rationale: The C/C++ manual documents the prototypes of the library
** functions using the intrinsic C data types and these prototypes must
** correspond to the actual prototypes that are defined in the header
** files. In addition, Rule 8.3 requires that the type of the result
** and the type of the parameters that are specified in a function
** definition and a function declaration are identical.
*/

#pragma diag(suppress:misra_rule_14_7)
/* Suppress Rule 14.7 (required) which requires that a function shall
** have a single point of exit at the end of the function.
**
** Rationale: The requirement is only suppressed provided that the only
** violation occurs at the beginning of the function when the function
** verifies its parameters are "correct".
*/
#endif /* _MISRA_RULES */

#include <filter.h>
#include <math.h>

extern void
coeff_iirdf1_fr32 (const long double _acoeff[],
                   const long double _bcoeff[],
                   fract32           _coeff[],
                   int               _nstages)
{

    const long double *const acoeff = _acoeff;
    const long double *const bcoeff = _bcoeff;
    fract32 *__restrict       coeff = _coeff;
    const int               nstages = _nstages;

    long double max_coeff;           /* Value of largest coefficient */
    int  scale_adj;                  /* Power of 2 of max_coeff      */
    int  i;

    /* Find the largest absolute value stored in acoeff, bcoeff */
    max_coeff = fabsd(bcoeff[0]);
    for (i = 0; i < (nstages*2); i++)
    {
        max_coeff = fmaxd(max_coeff,
                          fmaxd(fabsd(acoeff[i]),
                                fabsd(bcoeff[i+1]))
                         );
    }

    /* Set the scaling factor based on the largest coefficient*/
    frexpd(max_coeff, &scale_adj);

    /* Scale the coefficients and convert them to fixed point */
    for (i = 0; i < (nstages*2); i++)
    {
        coeff[(2*i)]   = (fract32) ldexpd( bcoeff[i], (31-scale_adj));
        coeff[(2*i)+1] = (fract32) ldexpd(-acoeff[i], (31-scale_adj));
    }
    coeff[(nstages*4)] = (fract32) ldexpd( bcoeff[(nstages*2)], (31-scale_adj));

    coeff[(nstages*4)+1] = scale_adj;

}

/* End of File */
