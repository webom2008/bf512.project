/************************************************************************
 *
 * iirdf1_fr16.asm
 *
 * (c) Copyright 2004-2007 Analog Devices, Inc.  All rights reserved.
 *
 ************************************************************************/

#if defined(__DOCUMENTATION__)

        Title:
        ------
        16-bit, Direct Form 1 IIR filter for Blackfin


            V    = B0 * X(i) + B1 * X(i-1) + B2 * X(i-2);
            Y(i) = V + A1 * Y(i-1) + A2 * Y(i-2)
                       where  i = [0, 1, .., n).


            #include <filter.h>
            void iirdf1_fr16 ( 
                       const fract16      x[],  /* Input buffer           */ 
                       fract16            y[],  /* Output buffer          */
                       int                n,    /* Size Input/Output data */
                       iirdf1_state_fr16  *s);  /* Filter data structure  */


        Description:
        -----------
        This is an optimized 16-bit, direct form I IIR filter.  
        The implementation makes use of both MAC units to achieve maximum 
        efficiency on the Blackfin.

        Two accompanying functions are provided to initialize the filter.  
        
        The function iirdf1_init() is always required, initialising the
        filter data structure iirdf1_state_fr16. 

            <iirdf1.h>
            typedef struct
            {
                       fract16 *c;    /* Coefficients                   */
                       fract16 *d;    /* Start of delay line            */
                       fract16 *p;    /* Read/write pointer delay line  */
                       int k;         /* 2*number of stages + 1         */
            } _iirdf1_fr16_state;

            typedef _iirdf1_fr16_state iirdf1_state_fr16;

            #define iirdf1_init(state, coeffs, delay, stages) \
                       (state).c = (coeffs); \
                       (state).d = (delay);  \
                       (state).p = (delay);  \
                       (state).k = (2*stages+1)

        The function coeff_iirdf1_fr16() is only required if any of the
        filter coefficients exceeds the maximum range of type fract16. 
        The function takes floating point filter coefficients in transposed 
        form (as generated by a filter design tool) as input and returns 
        scaled fractional coefficients. The scaling factor applied to the 
        A and B coefficients is returned as part of the coefficient array.

            void coeff_iirdf1_fr16 (const float _acoeff[], 
                       const float _bcoeff[],
                       fract16 _coeff[], 
                       int _nstages);       

        For optimum performance, coefficient and state data arrays should 
        be placed in separate memory blocks.

        The state array must be initialised to zero before the first call 
        to the iirdf1_fr16() function. It is used as temporary storage and 
        should not be modified outwith the function. 

        The length of the state array and the fractional coefficient array
        is 4 * nstages + 2. The input and output vector are of length n.


        Coefficient Organization:
        ------------------------

        There will always be one less a coefficient as the a0 coefficient 
        has been normalized. To make full use of the dual-MAC architecture, 
        coefficients are ordered in the following way:

            B0, A1, B1, A2, B2, Scaling Factor (0 if no scaling)  

        When the number of stages is greater than one, coefficients
        have to be supplied in transfer function representation, i.e.
            
            B0, A1, B1, A2, B2, A3, B4, A4, B5, Scal. Factor (0 if no scaling)

        for 2 stages.


        Cycle Count:
        -----------

        B = number of stages
        N = number of samples

                       43 + N * (2*B + 16)
                       (BF532, Cycle Accurate Simulator)

        Code Size:  76 Bytes 

******************************************************************************/
#endif

#if !defined(__NO_LIBRARY_ATTRIBUTES__)
.file_attr libGroup = filter.h;
.file_attr libName = libdsp;
.file_attr prefersMem = internal;
.file_attr prefersMemNum = "30";
.file_attr libFunc  = __iirdf1_fr16;
.file_attr libFunc  = iirdf1_fr16;
.file_attr FuncName = __iirdf1_fr16;
#endif

#if defined(__ADSPLPBLACKFIN__) && defined(__WORKAROUND_AVOID_DAG1)
#define __WORKAROUND_BF532_ANOMALY38__
#endif


.section        program;
.align 2;

.global         __iirdf1_fr16;
__iirdf1_fr16:

        P1 = [SP+12];           // P2 = Pointer to state structure
        I2 = R0;                // I2 = Data input pointer 
        I3 = R1;                // I3 = Data output pointer

        // Load Coefficient pointer 
        // I1 = Coefficient pointer (Implemented as Circular Buffer)
        R0 = [P1]; 
        B1 = R0;  
        I1 = R0;
        M2 = -2;

        // Load State (First element in delay line)
        R0 = [P1+4];
        B0 = R0;

        // Load State Restart Pointer (Next element to write to in delay line)
        // I0 = State pointer (Implemented as Circular Buffer)
        R0 = [P1+8]; 
        P0 = P1;
        I0 = R0; 

        // Load (2*number of stages + 1)
        R0 = [P1+12];
        P1 = R2;                // P1 = pts/Block Size
        R1 = R0 << 2; 
        L0 = R1; 
        L1 = R1;

        // Test for zero length input
        CC = P1 <= 0;
        IF CC JUMP iir_return;

        // Set inner loop counter = (2*number of stages)
        // Test for inner loop counter <= 0
        R0 += -1;

        CC = R0 <= 0;
        IF CC JUMP iir_return;

        P2 = R0;

        // Store address in filter state referencing restart pointer
        P0 += 8;

        // Loop for number of input samples
        LSETUP( iir_Block_Start, iir_Block_End) LC0 = P1;
iir_Block_Start:
                R3.L = W[I2++];         // Read input value X(i)
                W[I0] = R3.L;           // Store it in delay line

                A1=A0=0 || R1 = [I1++]; // Zero accumulators
                                        // and Read B0 and A1
                R2 = [I0++];            // Read X(i) and Y(i-1)

#if defined( __WORKAROUND_BF532_ANOMALY38__ )

                // Loop for (2*number of stages)
                LSETUP( iir_CoreS, iir_CoreE) LC1 = P2;
iir_CoreS:              A1+=R2.L*R1.L, A0+=R2.H*R1.H || R2=[I0++];
iir_CoreE:              R1=[I1++];

#else
                // Loop for (2*number of stages)
                LSETUP( iir_Core, iir_Core) LC1 = P2;
iir_Core:               A1+=R2.L*R1.L, A0+=R2.H*R1.H || R2=[I0++] || R1=[I1++]; 

#if defined(__WORKAROUND_INFINITE_STALL_202)
/* After 2 possible dual dag loads, need 2 prefetch loads to avoid the
** anomaly (since the first prefetch is still part of the anomaly sequence).
*/
                PREFETCH[SP];
                PREFETCH[SP];

#endif /*__WORKAROUND_INFINITE_STALL_202*/
#endif /*__WORKAROUND_BF532_ANOMALY38__*/

                A1+=R2.L*R1.L || I1 += M2; 
                                        // Final computation B coeff, Rewind I1
                A0 += A1 || R3.L = W[I1++] || I0 += M2;   
                                        // Add accumulators, load scaling factor
                                        // and position state pointer
                A0 = ASHIFT A0 BY R3.L; // Reverse scaling coefficients 
                R2.L = A0;
                W[I0--] = R2.L;         // Store result into delay line
iir_Block_End:
                W[I3++] = R2.L;         // Store result into output buffer

        R1 = I0;                        // Store r/w pointer delay line
        [P0] = R1;

iir_return:
        L0 = 0;
        L1 = 0;
        rts;

.__iirdf1_fr16.end:
