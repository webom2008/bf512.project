//* Copyright (C) 2003-2010 Analog Devices, Inc. All Rights Reserved. */
/*
** (Re)initialise the data areas for the application from a table
** generated by the MemInit tool.
*/
#pragma file_attr(  "libName=librt")
#pragma file_attr(  "libName=librt_fileio")
#pragma file_attr(  "libFunc=mi_initialize")
#pragma file_attr(  "libFunc=_mi_initialize")
#pragma file_attr(  "prefersMem=internal")
#pragma file_attr(  "prefersMemNum=30")

#include <string.h>
#include <ccblkfn.h>
#include <sysreg.h>
#include <limits.h>
#include <meminit.h>

#pragma file_attr("requiredForROMBoot")

#if defined(__ADSPLPBLACKFIN__)
#include <sys/platform.h>
#endif

#if defined(__ADSPBF592A__)
/* This part will be initializing the data from L1 Instruction ROM */
#define L1_ROM_START 0xFFA10000
#define L1_ROM_END   0xFFA1FFFF
#define PART_HAS_ROM

#define L1INSTRBASE 0xFFA00000
#define L1INSTREND  0xFFA07FFF

static __inline int in_l1_instr(unsigned long addr)
{
  if (L1INSTRBASE <= addr && addr < L1INSTREND)
    return 1;
  return 0;
}

#endif

extern mi_table_header *__inits;

#if !defined(__ADSPLPBLACKFIN__)

#define L1INSTRBASE  0xFFA00000
#define L1INSTREND  0xFFA04000

static __inline int in_l1_instr(unsigned long addr)
{
  if (L1INSTRBASE <= addr && addr < L1INSTREND)
    return 1;
#if defined(__ADSPLPBLACKFIN__)
  if (L1INSTRBASEB <= addr && addr < L1INSTRENDB)
    return 1;
#endif
  return 0;
}

#endif

#if defined(__ADSPLPBLACKFIN__)

#pragma never_inline
static void meminit_runtime_error(void) {
  /* we've run into something unexpected and can't continue */
  while (1)
    idle();
}

/* Can't DMA to Scratchpad */
#define SCRATCHPAD_START 0xFFB00000
#define SCRATCHPAD_END   0xFFB01000

static __inline int in_scratchpad(unsigned long addr)
{
  if (SCRATCHPAD_START <= addr && addr < SCRATCHPAD_END)
    return 1;
  return 0;
}

typedef struct {
  char *next_desc_ptr;  /* 0x00: Link pointer to next descriptor */
  char *start_addr;  /* 0x04: Start address of current buffer */
  unsigned short config;  /* 0x08: DMA configuration reg, including enable bit */
  unsigned short pad1;
  unsigned resv1;    /* 0x0C: Reserved */
  short x_count;    /* 0x10: Inner loop count */
  short pad2;
  short x_modify;    /* 0x14: Inner loop address increment, in bytes */
  short pad3;
  short y_count;    /* 0x18: Outer loop count (2D only) */
  short pad4;
  short y_modify;    /* 0x1C: Outer loop address increment, in bytes */
  short pad5;
  char *curr_desc_ptr;  /* 0x20: Current Descriptor pointer */
  char *curr_addr;  /* 0x24: Current DMA Address */
  unsigned short irq_status;  /* 0x28: Interrupt Status Register. */
  short pad8;
  unsigned periph_map;  /* 0x2C: Peripheral-to-DMA-Channel mapping */
  short curr_x_count;  /* 0x30: Current count (1D) or intra-row count (2D) */
  short pad6;
  unsigned resv2;    /* 0x34: Reserved */
  short curr_y_count;  /* 0x38: Current row count (2D only) */
  short pad7;
  unsigned resv3;    /* 0x3C: Reserved */
} MemDMAChan;


/*
** Initialise DMA channels ready for use.
*/

static __inline void init_dma(void)
{
   /* set MemDMA Stream 0 bit in SIC_IMASK and SIC_IAR */
#if !defined(__SILICON_REVISION__) || \
     defined(__ADSPBF537_FAMILY__) || defined(__ADSPBF538_FAMILY__)
   /* Determine which SIC MMRs and bits to set at runtime -
   ** This is needed when building for silicon revision none as 
   ** the module linked in that situation is built for BF532 and
   ** the BF532 configuration won't work for all parts.
   ** Runtime checks are also needed for the BF537 and BF528 series
   ** parts as they use a single library build but have different SIC
   ** MMRs
   */
   unsigned int partno = ((*(unsigned int *)0xFFC00014)&0x0FFFF000)>>12;
   if ((partno==0x27C6)||(partno==0x27C7)||(partno==0x27C8)||
       (partno==0x2802)) {
     /* BF53[467]/BF592 */
     *((volatile unsigned long  *)0xFFC0010C) |= (1u<<29);
     *((volatile unsigned long  *)0xFFC00124) |= (1u<<29);
   } else if (partno==0x27BB) { 
     /* BF561 */
     *((volatile unsigned long  *)0xFFC00110) |= (1u<<21);
     *((volatile unsigned long  *)0xFFC00120) |= (1u<<21);
   } else if((partno==0x27E0)||(partno==0x27E4)||
             (partno==0x27E8)||(partno==0x2800)) {
     /* BF52[357]/BF52[246]/BF51[246]/BF50[456] */
     *((volatile unsigned long  *)0xFFC0014C) |= (1u<<10);  
     *((volatile unsigned long  *)0xFFC00164) |= (1u<<10);
   } else { 
     /* BF532/BF538/BF539/BF54[24789] */
     *((volatile unsigned long  *)0xFFC0010C) |= (1u<<21);
     *((volatile unsigned long  *)0xFFC00124) |= (1u<<21);
   }
#elif defined(__ADSPBF561__) || defined(__ADSPBF566__)
  *pSICA_IMASK1 |= (1<<21);
  *pSICA_IWR1   |= (1<<21);
#elif defined(__ADSPBF54x__)
  *pSIC_IMASK0  |= (IRQ_MDMA0);
  *pSIC_IWR0    |= (IRQ_MDMA0);  /* MemDMA Stream 0 */
#elif defined(__ADSPBF52x__) || defined(__ADSPBF51x__) || defined(__ADSPBF50x__)
  *pSIC_IMASK1  |= (IRQ_DMA12);
  *pSIC_IWR1    |= (IRQ_DMA12);
#elif defined(__ADSPBF59x__)
  *pSIC_IMASK0  |= (IRQ_DMA12);
  *pSIC_IWR0    |= (IRQ_DMA12);
#else
  *pSIC_IMASK   |= (MDMA0_IRQ);  
  *pSIC_IWR     |= (MDMA0_IRQ);  
#endif
}

#define MDMA0_S0_NEXT_DESC_PTR_BF537  0xFFC00F40 
#define MDMA0_D0_NEXT_DESC_PTR_BF537   0xFFC00F00
#define MDMA0_S0_NEXT_DESC_PTR_BF538  0xFFC00E40
#define MDMA0_D0_NEXT_DESC_PTR_BF538  0xFFC00E00

static __inline volatile MemDMAChan *get_src0_addr(void)
{
#if defined(__ADSPBF561__) || defined(__ADSPBF566__)
  return (volatile MemDMAChan *)MDMA1_S0_NEXT_DESC_PTR;
#elif !defined(__SILICON_REVISION__) || \
       defined(__ADSPBF537_FAMILY__) || defined(__ADSPBF538_FAMILY__)
   /* Determine which MMRs to use at runtime */
  unsigned int partno = ((*(unsigned int *)0xFFC00014)&0x0FFFF000)>>12;

  if ((partno==0x27C6)||(partno==0x27C7)||(partno==0x27C8) || /* BF53[467] */
       (partno==0x2802)||                                      /* BF592     */
       (partno==0x2800)||                                      /* BF50[456] */
       (partno==0x27E8)||                                      /* BF51[246] */
       (partno==0x27DE)||                                      /* BF54[24789] */
       (partno==0x27E0)||                                      /* BF52[357] */
       (partno==0x27E4))                                       /* BF52[246] */
   {
    return (MemDMAChan *) MDMA0_S0_NEXT_DESC_PTR_BF537;  /* 0xFFC00F40 */
  } else { /* BF538/BF539/BF532 etc */
    return (MemDMAChan *) MDMA0_S0_NEXT_DESC_PTR_BF538;  /* 0xFFC00E40 */
  }
#else
  return (volatile MemDMAChan *)MDMA_S0_NEXT_DESC_PTR;
#endif
}

static __inline volatile MemDMAChan *get_dst0_addr(void)
{
#if defined(__ADSPBF561__) || defined(__ADSPBF566__)
  return (volatile MemDMAChan *)MDMA1_D0_NEXT_DESC_PTR;
#elif !defined(__SILICON_REVISION__) || \
       defined(__ADSPBF537_FAMILY__) || defined(__ADSPBF538_FAMILY__)
   /* Determine which MMRs to use at runtime */
  unsigned int partno = ((*(unsigned int *)0xFFC00014)&0x0FFFF000)>>12;

  if ((partno==0x27C6)||(partno==0x27C7)||(partno==0x27C8) || /* BF53[467] */
       (partno==0x2802)||                                      /* BF592     */
       (partno==0x2800)||                                      /* BF50[456] */
       (partno==0x27E8)||                                      /* BF51[246] */
       (partno==0x27DE)||                                      /* BF54[24789] */
       (partno==0x27E0)||                                      /* BF52[357] */
       (partno==0x27E4))                                       /* BF52[246] */
   {
    return (volatile MemDMAChan *) MDMA0_D0_NEXT_DESC_PTR_BF537; /* 0xFFC00F00 */
  } else { /* BF538/BF539/BF532/ etc */
    return (volatile MemDMAChan *) MDMA0_D0_NEXT_DESC_PTR_BF538; /* 0xFFC00E00 */
  }
#else
   return (MemDMAChan *)MDMA_D0_NEXT_DESC_PTR;
#endif
}

/*
** Use channel 0/1 to copy raw data to destination.
** Assumes that SIC_IWR is already configured.
*/

static void raw_dma(char *src, char *dst, int n)
{
    unsigned src_ctrl = DMAEN ;  // 8-bit read, no interrupt, stop, 1D
    unsigned dst_ctrl = DMAEN | WNR | DI_EN;  // 8-bit write, intr, stop, 1D

    volatile MemDMAChan *src0 = get_src0_addr();
    volatile MemDMAChan *dst0 = get_dst0_addr();
    unsigned short count;

    /* Disable the channels first, and clean their counters */
    src0->config = 0;
    src0->curr_x_count = 0;
    src0->curr_addr = 0;

    dst0->config = 0;
    dst0->curr_x_count = 0;
    dst0->curr_addr = 0;

    src0->x_modify = 1;         // advancing a byte at a time
    dst0->x_modify = 1;

    while ( n ) {
        src0->start_addr = src;
        dst0->start_addr = dst;
        
        // chunk to short maximum or smaller
        if (n > USHRT_MAX) {
            count = USHRT_MAX;   
        } else {
            count = n; 
        }
        src0->x_count = count;
        dst0->x_count = count;
        src0->config = src_ctrl;
        dst0->config = dst_ctrl;
        idle();                 // wait for interrupt
        dst0->irq_status = 1;   // acknowledge interrupt

        // adjust "n" and addresses
        n -= count;             // subtract what we just did from the count 
        dst = dst0->curr_addr;  // adjust Dest address
        src = src0->curr_addr;  // adjust the source as well.
    }
}

/*
** Use channel 0/1 to zero-fill a block of memory.
** Assumes that SIC_IWR is already configured.
*/

static void zero_dma(char *dst, int n)
{  
    unsigned src_ctrl = DMAEN ; // 8-bit read, no interrupt, stop, 1D
    unsigned dst_ctrl = DMAEN | WNR | DI_EN; // 8-bit write, intr, stop, 1D
    static const volatile char zero = 0;  // cannot be an auto as stack might
                                          // be in scratchpad
    volatile MemDMAChan *src0 = get_src0_addr();
    volatile MemDMAChan *dst0 = get_dst0_addr();
    unsigned short count; 
       
    /* Disable the channels first, and clean their counters */
    src0->config = 0;
    src0->curr_x_count = 0;
    src0->curr_addr = 0;
    
    dst0->config = 0;
    dst0->curr_x_count = 0;
    dst0->curr_addr = 0;
    
    src0->x_modify = 0;         // Not advancing at all
    dst0->x_modify = 1;         // advancing a byte at a time
    src0->start_addr = (char *)&zero;
    
    while ( n ) {  
       dst0->start_addr = dst;
        /* chunk to short maximum or smaller */
        if (n > USHRT_MAX) {
            count = USHRT_MAX;   
        } else {
            count = n;  
        }   
        src0->x_count = count;
        dst0->x_count = count;
        src0->config = src_ctrl;
        dst0->config = dst_ctrl; 
        idle();                 // wait for interrupt
        dst0->irq_status = 1;   // acknowledge interrupt

        /* adjust "n" and addresses */
        n -= count;             // subtract what we just did from the count
        dst = dst0->curr_addr;  // adjust Dest address 
    }
}  


/*
** Use channel 0/1 to copy a repeated pattern n times, via 2D DMA
** len is the length of the pattern. n is the total number of bytes
** to be written to dest.
** Assumes that SIC_IWR is already configured.
*/

static void pattern_dma(char *src, char *dst, int len, int n)
{
    unsigned src_ctrl1 = DMAEN ;  // 8-bit read, no interrupt, stop, 1D
    unsigned dst_ctrl1 = DMAEN | WNR | DI_EN;  // 8-bit write, intr, stop, 1D
    unsigned src_ctrl2 = src_ctrl1 | DMA2D;
    unsigned dst_ctrl2 = dst_ctrl1 | DMA2D;
    unsigned niters, remainder;
    unsigned src_advance = 1;
    volatile MemDMAChan *src0 = get_src0_addr();
    volatile MemDMAChan *dst0 = get_dst0_addr();
    unsigned short count; 
   
    dst0->x_modify = 1;
    src0->y_modify = -(len-1);  // back to start of pattern
    dst0->y_modify = 1;         // to next dst
    src0->start_addr = src;

    if (len!=1 && len!=2 && len!=4)
      meminit_runtime_error();

    while (n) {
        // chunk to short maximum or smaller
        if (n > USHRT_MAX) {
            count = USHRT_MAX & (~3);   
        } else {
            count = n;  
        }   

        src0->x_count = len;    // len bytes of pattern
        dst0->x_count = len;
        src0->x_modify = 1;     // advancing a byte at a time
        dst0->start_addr = dst;

        if (len == 1) {
            /* Can skip the 2D part for one-byte patterns */
            remainder = count;
            src_advance = 0;
        } else {
            if (len == 4) {
                niters = count >> 2;
                remainder = count & 3;
            } else {
                /* len == 2 */
                niters = count >> 1;
                remainder = count & 1;
            }
            src0->y_count = niters;
            dst0->y_count = niters;
            src0->config = src_ctrl2;
            dst0->config = dst_ctrl2;
            idle();                // wait for interrupt
            dst0->irq_status = 1;  // acknowledge interrupt
            dst = (char *)dst0->curr_addr;  // where remainder writes to
        }

        if (remainder) {
            /* Use a 1D-DMA to transfer the rest. */
            src0->x_count = remainder;      // copy part of pattern
            dst0->x_count = remainder;
            src0->x_modify = src_advance;
            src0->start_addr = src;
            dst0->start_addr = dst;
            src0->config = src_ctrl1;
            dst0->config = dst_ctrl1;
            idle();               // wait for interrupt
            dst0->irq_status = 1; // acknowledge interrupt
        }
        dst = (char *)dst0->curr_addr;    // where remainder writes to
        n -= count;               // subtract what we just did from the count
    }
}

#endif

#if defined(PART_HAS_ROM)
#define IS_IN_ROM(x) \
        (((unsigned)x >= L1_ROM_START) && ((unsigned)x < L1_ROM_END))

#define L1_MEMCPY_SRC_ALIGNMENT 8
#define L1_MEMCPY_DEST_ALIGNMENT 4
#define L1_MEMCPY_LENGTH_ALIGNMENT 8

static void *aligned_l1_memcpy(void *dest, void *src, size_t len) {
  /* Wrapper function for _l1_memcpy, that ensures that the src
  ** pointer is aligned as required.
  ** Assertion: Enough destination space should be provided so that alignment
  ** of the src pointer can be corrected without overflowing the end of dest.
  ** Assertion: src can be safely be rounded for alignment without reading
  ** off the start of the memory region and triggering an exception - likewise
  ** it won't read off the end if we need to round up len.
  ** The function returns a pointer to the start of the copied data;
  ** this may be the dest param, or some offset above it to adjust for the
  ** alignment of src. The function return NULL on failure.
  */
  unsigned src_offset = 0;
  void *res;
  if ( ((unsigned)dest) % L1_MEMCPY_DEST_ALIGNMENT  != 0 )
    return NULL;
  src_offset = (unsigned)src % L1_MEMCPY_SRC_ALIGNMENT;
  if ( src_offset != 0 ) {
    src = (void *)((unsigned)src - src_offset);
    len = len + src_offset;
  }
  /* Round up the length if required */
  if ( len % L1_MEMCPY_LENGTH_ALIGNMENT ) {
    len = ( len & ~0x7 ) + 0x8;
  }
  /* Assetion: dest was allocated on the stack as the correct type, 
  ** and as such will be suitable aligned.
  */
  res = _l1_memcpy(dest,src,len);
  if ( res == NULL )
    return NULL;
  dest = (void *)((unsigned)dest + src_offset );
  return dest;
}
#else
#define IS_IN_ROM(x) (0)
#define aligned_l1_memcpy(x,y,z) (0)
#endif

#define INITIALIZE_MEMINIT_PTR(mi_ptr, src, dest) \
  do { \
    if ( IS_IN_ROM(src) ) \
      mi_ptr = (mi_table_header *)aligned_l1_memcpy((void *)&(dest), \
                (void *)src, \
                sizeof(mi_table_header)); \
    else \
      mi_ptr = src; \
  } while ( 0 )

#define INITIALIZE_INITS_COPY_PTR(i_ptr, dest) \
  do { \
    if ( IS_IN_ROM((&__inits) )) { \
      void * _tmp; \
      _tmp = (mi_table_header *)aligned_l1_memcpy((void *)&(dest), \
              (void *)&__inits, \
              8); \
      i_ptr = (mi_table_header *)(*(unsigned *)_tmp); \
    } else { \
      i_ptr = __inits; \
    } \
  } while (0)

#define GET_MEMINIT_BLOCK_HDR() \
  do { \
    if ( bootstream_in_rom ) \
      block = (mi_block_header *)aligned_l1_memcpy((void *)&mi_blk_copy, \
                  (void *)inits_block_src_ptr, \
                  sizeof(mi_block_header)); \
    else \
      block = (mi_block_header *)src; \
  } while (0)

#define INCREMENT_MEMINIT_BLOCK_PTR() \
  do { \
    if ( bootstream_in_rom ) \
      src = (char *)(++inits_block_src_ptr); \
    else \
      src = (char *)(block+1); \
  } while ( 0 )

#define SET_MEMINIT_BLOCK_PTR(p) \
  do { \
    if ( bootstream_in_rom ) \
      inits_block_src_ptr = (mi_block_header *)p; \
  } while ( 0 );

#if defined(PART_HAS_ROM)
static void copy_rom_data(char *src, char *dest, unsigned cnt) {
  if (((((unsigned)src) & 0x7) == 0 ) && 
       ((((unsigned)dest) & 0x3) == 0 ) &&
       ((((unsigned)cnt) & 0x7) == 0 ) ) {
    /* All our parameters are correctly aligned allowing us to do a single
    ** _l1_memcpy.
    */
    _l1_memcpy(dest,src,cnt);
    src += cnt;
  } else {
    unsigned alignment_adjust = 0;
    unsigned memcpy_tmp[8];
    unsigned copy_len;
    char *aligned_src, *aligned_dest, *curpos;
    if ( cnt > 16 ) {
      /* We do the copy in potentially three stages:
      ** 1. If src is not 8-byte aligned, copy up to the alignment point,
      **    via a temp in the stack.
      ** 2. direct _l1_memcpy from the now aligned src, to it's last 
      **    multiple of 8 (requirement of _l1_memcpy that count is a 
      **    multiple of 8).
      **    If dest is NOT 4-byte aligned we round dest up (reduce the 
      **    count), and copy. We then shift all the bytes down in dest
      **    (data RAM).
      ** 3. Copy any remaining bytes via the stack.
      */
      if ( ((unsigned)src) & 0x7 ) {
        // leading copy
        aligned_src = (char *)(((unsigned)src) & ~0x7);
        alignment_adjust = src - aligned_src;
        copy_len = 8;
        _l1_memcpy((void *)&memcpy_tmp,aligned_src,copy_len);
        copy_len = 8 - alignment_adjust;
        curpos = (char *)&memcpy_tmp;
        curpos += alignment_adjust;
        cnt -= copy_len;
        src += copy_len;
        while ( copy_len ) {
          *dest++ = *curpos++;
          copy_len--;
        }
      }
      // src is now 8-byte aligned. But dest may not be 4-byte aligned.
      alignment_adjust = 0;
      copy_len = cnt;
      aligned_dest = dest;
      if ( ((unsigned)dest) & 0x3 )  {
        /* round up the dest address to the next multiple of 4.
        ** Round down the count, we need to ensure we don't overwrite 
        ** other data with our l1_memcpy.
        */
        aligned_dest = (char *)(((unsigned)dest) & ~0x3) + 0x4;
        alignment_adjust = aligned_dest - dest;
        copy_len -= 4;
      }
      /* Check copy_len is a multiple of 8, if not round it down. */
      if( copy_len & 0x7 ) {
        copy_len = copy_len & ~0x7;
      }
      /* Do the l1_memcpy */
      _l1_memcpy((void *)aligned_dest,src,copy_len);
      /* Shift the data if required */
      cnt -= copy_len;
      src += copy_len;
      if ( alignment_adjust ) {
        while ( copy_len ) {
          *dest++ = *aligned_dest++;
           copy_len--;  
        }  
      } else {
        dest += copy_len;
      }
    }
    if ( cnt ) {
      /* Fallthrough from above, and covers case for small sections of
      ** data:
      ** Copy all remaining bytes using a temporary on the stack.
      **  Be aware that src may not be aligned and may need to be 
      **  rounded down.
      */
      copy_len = cnt;
      alignment_adjust = 0;
      if ( ((unsigned)src) & 0x7 ) {            
        aligned_src = (char *)(((unsigned)src) & ~0x7);
        alignment_adjust = src - aligned_src;
        copy_len += alignment_adjust;
      } else {
        aligned_src = src;
      }
      if ( copy_len & 0x7 ) {
        copy_len = ( copy_len & ~0x7 ) + 0x8;
      }
      _l1_memcpy((void *)&memcpy_tmp,(void *)aligned_src, copy_len);
      curpos = (char *)&memcpy_tmp;
      curpos += alignment_adjust;
      copy_len = cnt;
      while ( copy_len ) {
        *dest++ = *curpos++;
        copy_len--;
      }
      src += cnt;
    }
  }
}
#endif

int mi_initialize(void)
{
  mi_block_header *block;
  mi_table_header *meminit;
  char *src, *dest;
  void (*fnptr)(void);
  unsigned long bn = 0, num_blocks;
  mi_table_header *inits_ptr;
  mi_block_header *inits_block_src_ptr; // Used in ROM parts to point to the next meminit block header, in ROM
  int bootstream_in_rom;
  /* additional space is required to deal with misaligned
  ** values being copied out of ROM.
  */
#if defined(PART_HAS_ROM)
  unsigned  *inits_copy[2];
  mi_table_header mi_hdr_copy[2];
  mi_block_header mi_blk_copy[2];
#endif

  INITIALIZE_INITS_COPY_PTR(inits_ptr,inits_copy);
  INITIALIZE_MEMINIT_PTR(meminit,inits_ptr, mi_hdr_copy);
  if ( meminit == NULL )
    return -1;
  bootstream_in_rom = IS_IN_ROM(inits_ptr);
  SET_MEMINIT_BLOCK_PTR(&inits_ptr->blocks[0]);
  if (meminit == 0)
    return 0;  /* MemInit wasn't used to build a table */
  csync();
  if (meminit->magic.magic != MI_MAGIC_BLACKFIN ||
      meminit->magic.version != 0)
    return -1;  /* not an init table we recognise */
  num_blocks = meminit->num_blocks;
  if (num_blocks == 0)
    return 0;  /* no blocks to initialise */
#if defined(__ADSPLPBLACKFIN__)
  init_dma();
#endif
  /* Point to the first block.
  ** For applications in ROM, this has already been copied across as part of the
  ** __inits header.
  */
  block = meminit->blocks;
  while (bn++ < num_blocks) {
    int i, j, cnt;
    unsigned long type;
    unsigned long addr;
  
  type = block->flags;

    /* validation */
    if (((type & MI_WS_BITS)>>MI_WS_POS) != MI_WS_8BITS)
      return -1;
    if (((type & MI_MEM_BITS)>>MI_MEM_POS) != MI_MEM_US)
      return -1;
    type &= MI_BT_BITS;
    type >>= MI_BT_POS;

    switch (type) {
    case MI_BT_RAW:
#if defined(PART_HAS_ROM)
      if ( bootstream_in_rom ) {
        src = (char *)(inits_block_src_ptr+1);
        dest = block->addr;
        cnt = block->byte_count;
      /* We don't support the initialization of L1 Instr RAM from L1 Instr ROM.
      ** There is no direct path between the two so any initialization would 
      ** require an _l1_memcpy from ROM to stack, then into RAM with memcpy_l1.
      ** As this needs to be copied via the stack we don't know how much
      ** free space we have and would have to copy just a few bytes at a time.
      ** This is far too expensive.
      */
        if ( in_l1_instr((unsigned long) dest)) {
          return -1;
        }
        copy_rom_data(src,dest,cnt);
        addr = (unsigned long)src + cnt;
        if (addr & 0x3)
          addr += 4;
        addr &= ~0x3;
        src = (char *)addr;
        SET_MEMINIT_BLOCK_PTR(addr);
      } else {
#endif
      /* copy the data directly */
      src = (char *)(block+1);
      dest = block->addr;
      cnt = block->byte_count;
#if defined(__ADSPLPBLACKFIN__)
      if (!in_scratchpad((unsigned long)dest)) {
        raw_dma(src, dest, cnt);
        src += cnt;
      } else {
        /* Don't need to worry about the l1_instr case, as it'll be
         * caught by the DMA case above */
        for (i = 0; i < cnt; i++)
          *dest++ = *src++;
      }
#else
      if (in_l1_instr((unsigned long)dest)) {
        if (_memcpy_l1(dest, src, cnt) != dest) {
          return -1;
        } else {
          src += cnt;
        }
      } else {
        for (i = 0; i < cnt; i++)
          *dest++ = *src++;
      }
#endif
      /* round up to start of next word */
      addr = (unsigned long)src;
      if (addr & 0x3)
        addr += 4;
      addr &= ~0x3;
      src = (char *)addr;
#if defined(PART_HAS_ROM)
   }
#endif
      break;
    case MI_BT_ZERO:
      /* Zero-fill the target section */
      /* For parts where the boot is in ROM, we can still use the zero_dma routine */
      dest = block->addr;
      cnt = block->byte_count;
#if defined(__ADSPLPBLACKFIN__)
      if (!in_scratchpad((unsigned long)dest)) {
        zero_dma(dest, cnt);
      } else
#endif
      /* don't add code here */
      for (i = 0; i < cnt; i++)
        *dest++ = 0;
      INCREMENT_MEMINIT_BLOCK_PTR();
      break;
    case MI_BT_CALL:
      /* Call the block as an initialization function */
      /* No action required from mi_initialise if this block is in ROM */
      fnptr = (void (*)(void))block->addr;
      (*fnptr)();
      INCREMENT_MEMINIT_BLOCK_PTR();
      break;
    case MI_BT_REP:
      /* keep repeating the pattern until we've filled
         the section to the requested number of bytes.
         No guarantee that byte_count % pattern_bytes == 0. */
      {
#pragma diag(suppress:177)
        unsigned char pattern_copy[block->pattern_bytes+16];
        char *src_copy;
        j = 0;

        if ( bootstream_in_rom ) {
          src = src + sizeof(mi_block_header);
          src_copy = src;
          src = aligned_l1_memcpy((void *)&pattern_copy,src,
                                  block->pattern_bytes);
        } else {
        	src = (char *)(block+1);
        }
        dest = block->addr;
        cnt = block->byte_count;
#if defined(__ADSPLPBLACKFIN__)
        if (!in_scratchpad((unsigned long)dest))
          pattern_dma(src, dest, block->pattern_bytes, cnt);
        else
#endif
        /* don't add code here */
        for (i = 0; i < cnt; i++) {
          dest[i] = src[j];
          j = circindex(j, 1, block->pattern_bytes);
        }
        /* round up the pattern length to 32-bit multiple. */
        if ( bootstream_in_rom ) {
        	src = src_copy;
        }
        addr = block->pattern_bytes;
        if (addr & 0x3)
          addr += 4;
        addr &= ~0x3;
        /* advance pointer by that much */
        src += addr;
        SET_MEMINIT_BLOCK_PTR(src);
      }
      break;
    default:
      return -1;
    }
    /* src now points to the beginning of the next block */
    GET_MEMINIT_BLOCK_HDR();
  }
  return 0;
}

